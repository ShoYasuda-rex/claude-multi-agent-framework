---
name: gen-arch
description: コード実態からアーキテクチャドキュメントを自動生成
model: sonnet
tools: Read, Glob, Grep, Write, Task
user_invocable: true
---

# プロジェクト構造ドキュメント生成スキル

プロジェクトのコードベースを分析し、以下の3つのドキュメントを生成・上書きする:

- `docs/current/architecture.md` — 実際の技術構成・データフロー
- `docs/current/screen-flow.md` — 実際の画面遷移・状態遷移
- `docs/current/component-rules.md` — 実際のコード規約・パターン

---

## プロジェクト情報の取得

以下の優先順位でプロジェクト名・技術スタックを特定:
1. `package.json` / `Gemfile` / `requirements.txt` / `go.mod` 等
2. `CLAUDE.md` 内の記載
3. ディレクトリ名・構成から推測

---

## STEP 1: コードベース探索

### 探索対象

```
Glob: **/*.{html,jsx,tsx,vue,svelte,erb,ejs,pug}
Glob: **/*.{js,ts,rb,py,go,java,rs}
Glob: **/*.{css,scss,sass,less}
Glob: **/schema.prisma, **/models/**, **/migrations/**
Glob: **/routes/**, **/router/**, **/pages/**, **/app/**
Glob: **/docker-compose.yml, **/Dockerfile, **/*.yaml, **/*.yml
```

除外:
- `node_modules/`, `dist/`, `build/`, `.next/`, `vendor/`, `__pycache__/`

### 確認すること

- ディレクトリ構造の全体像
- フロントエンド: フレームワーク、ルーティング、状態管理、UIライブラリ
- バックエンド: フレームワーク、API構造、ミドルウェア、認証方式
- データベース: ORM/スキーマ定義、モデル構造、マイグレーション
- インフラ: デプロイ構成、環境変数管理
- 状態管理: 認証状態、フロー/ステップ進行、同期状態、モード切替などの状態遷移パターン
- 条件分岐: ミドルウェアのリクエスト判定、ページ初期化時の認証チェック・リダイレクト、データの信頼度判定・保存ロジック、モード切替ロジックなど、コード内の主要な if/else・switch フロー
- 共通パターン: 命名規則、ファイル配置ルール、import規約

---

## STEP 2: docs/current/architecture.md の生成

以下の構成で出力する（上書き）:

```markdown
# {プロジェクト名} アーキテクチャ設計

## 技術スタック

| レイヤー | 技術 | バージョン | 用途 |
|---------|------|-----------|------|
| フロントエンド | React / Next.js | 14.x | UI描画・ルーティング |
| バックエンド | Node.js / Express | 18.x | API サーバー |
| データベース | PostgreSQL | 15 | データ永続化 |
| インフラ | Docker / Heroku | - | デプロイ |
| ... | ... | ... | ... |

## ディレクトリ構成

（実際の構成をツリー形式で記載。主要ディレクトリに説明コメントを付与）

## アーキテクチャ概要図

（ASCIIアートでレイヤー構成・データフローを図示）

## データフロー

リクエストからレスポンスまでの流れを記述:
1. クライアント → API Gateway / ルーティング
2. ミドルウェア（認証・バリデーション）
3. コントローラー / ハンドラー
4. サービス層 / ビジネスロジック
5. データアクセス層（ORM / クエリ）
6. レスポンス生成

## データモデル

主要なエンティティとリレーションを記述:

| モデル | 主要フィールド | リレーション |
|--------|---------------|-------------|
| User | id, email, name | has_many: Posts |
| ... | ... | ... |

## 外部連携

外部API・サービスとの連携があれば記載:
- 認証プロバイダ（OAuth等）
- メール送信サービス
- ストレージ（S3等）
- AI/ML API
```

---

## STEP 3: docs/current/screen-flow.md の生成

以下の構成で出力する（上書き）:

### 画面の特定方法

- **SPA（React/Vue/Svelte等）**: ルーティング定義ファイルを優先参照（`pages/`, `app/`, `router/`）
- **MPA（HTML/ERB/EJS等）**: HTMLファイルのリンク・フォーム遷移を解析
- **モバイル/デスクトップ**: ナビゲーション定義を参照

```markdown
# {プロジェクト名} 画面遷移図

## 全体フロー図

（ASCIIアートで画面遷移を図示。画面数に応じてレイアウトを調整）

## ユーザージャーニー

### 新規ユーザー
1. トップページにアクセス
2. ...

### 既存ユーザー
1. ログイン
2. ...

### 管理者（該当する場合）
1. 管理画面にアクセス
2. ...

## 画面一覧

| パス / ルート | 画面名 | 目的 | 主要アクション |
|--------------|--------|------|----------------|
| / | トップ | 初回訪問者の案内 | サービス説明、登録誘導 |
| /login | ログイン | 認証 | メール/パスワード入力 |
| ... | ... | ... | ... |

## API エンドポイント一覧

| メソッド | パス | 用途 | 認証 |
|---------|------|------|------|
| GET | /api/users | ユーザー一覧取得 | 要 |
| POST | /api/auth/login | ログイン | 不要 |
| ... | ... | ... | ... |

## 主要な状態遷移

アプリ内部で管理される主要な状態とその遷移を記述する。
コードから状態管理のパターン（フラグ、enum、フェーズ変数、ステータス管理等）を探索し、以下の形式で図示する。

### 状態遷移の探索方法

- グローバル/モジュール変数で管理される状態（`state`, `status`, `phase`, `mode`, `step` 等）
- localStorage / sessionStorage に保存される状態フラグ
- URL パラメータやハッシュで制御される状態（`?mode=`, `?step=` 等）
- 認証・セッション状態
- データ同期・通信状態
- ウィザード/フロー内のステップ進行

### 出力形式

状態遷移ごとにASCIIアートで図示し、トリガー（遷移条件）を明記する:

（例）
```
### 認証状態
未認証 --[ログイン成功]--> ログイン済 --[セッション期限切れ]--> 未認証
                                     --[ログアウト]-----------> 未認証

### ワークフロー状態
（該当する状態遷移をASCIIアートで記述）
```

各状態遷移について以下を記載:
| 状態遷移名 | 管理方法 | 状態一覧 | トリガー |
|-----------|----------|---------|---------|
| 認証状態 | Cookie + セッション | 未認証, ログイン済 | login/logout API |
| ... | ... | ... | ... |

## 主要な条件分岐図

コード内の主要な条件分岐ロジックをフローチャート形式で図示する。
単純な null チェックや型チェック等の些末なものは対象外。ビジネスロジック・セキュリティ・データフローに関わる分岐を対象とする。

### 条件分岐の探索方法

- ミドルウェア / ガード: リクエスト受付 → 認証・権限チェック → 許可/拒否の分岐
- ページ初期化: DOMContentLoaded → 認証状態チェック → リダイレクト or データロードの分岐
- データ処理: API応答パース → バリデーション → 信頼度/ステータスに応じた保存・表示・破棄の分岐
- モード切替: URLパラメータ/フラグに応じた表示・動作の切替
- エラーハンドリング: try-catch → リトライ / フォールバック / ユーザー通知の分岐

### 出力形式

各条件分岐をASCIIフローチャートで図示し、判定条件と結果アクションを明記する:

（例）
```
### ミドルウェア認証判定

リクエスト受信
    │
    ▼
[認証不要パスか？]──Yes──→ そのまま通過（next()）
    │ No
    ▼
[Cookie に session_id があるか？]──No──→ 401 Unauthorized
    │ Yes
    ▼
[D1 でセッション有効か？]──No──→ 401 Unauthorized
    │ Yes
    ▼
[セッション期限内か？]──No──→ 401 Unauthorized
    │ Yes
    ▼
context.data.user に設定 → next()
```

各条件分岐について以下を記載:
| 分岐名 | 実装箇所 | 判定条件 | 結果パターン |
|--------|---------|---------|-------------|
| ミドルウェア認証 | _middleware.js | パス・Cookie・セッション | 通過, 401 |
| ... | ... | ... | ... |
```

---

## STEP 4: docs/current/component-rules.md の生成

実際のコードから規約パターンを読み取り、以下の構成で出力する（上書き）:

```markdown
# {プロジェクト名} コンポーネント規約

## ファイル・ディレクトリ命名規則

| 対象 | 規則 | 例 |
|------|------|-----|
| コンポーネント | PascalCase | `UserProfile.tsx` |
| ユーティリティ | camelCase | `formatDate.ts` |
| スタイル | コンポーネント名.module.css | `UserProfile.module.css` |
| テスト | *.test.ts / *.spec.ts | `UserProfile.test.tsx` |
| ... | ... | ... |

## コンポーネント設計パターン

（実際のコードから読み取ったパターンを記述）

- コンポーネントの分類（pages / features / shared / ui 等）
- Props の定義方法（interface / type）
- 状態管理の方針（ローカル / グローバル / サーバーステート）
- スタイリング方式（CSS Modules / Tailwind / styled-components 等）

## バックエンドの構成規約

- コントローラー / ルートの定義パターン
- サービス層の責務
- モデル / リポジトリの設計
- エラーハンドリングの方針
- バリデーションの実装箇所

## 共通ルール

- import の順序（外部 → 内部 → 相対パス等）
- エクスポートの方式（named / default）
- 型定義の配置場所
- 定数・設定値の管理方法
- 環境変数の扱い

## やってはいけないこと（実際のコードから推測できる場合のみ記載）

- ビジネスロジックをコンポーネント内に直接書かない
- API呼び出しをコンポーネントから直接行わない
- 等、プロジェクト固有のアンチパターン
```

---

## 注意事項

- 各ドキュメントは毎回上書きする（差分追記ではない）
- `docs/current/` ディレクトリが存在しない場合は作成する
- **Write前の必須手順**: 出力先の3ファイルが既に存在するかを Glob で確認し、存在するファイルは Write の前に必ず Read で読み取ること（Write ツールは未読ファイルへの上書きをブロックするため）。新規ファイルはそのまま Write してよい
- 実際のコードに存在しない情報は推測で書かない。不明な場合は「要確認」と記載する
- ASCIIアートの図は、要素数に応じて適切なレイアウトを選択する
- 大規模プロジェクトの場合は、機能グループごとにセクション分けする
- 既存の CLAUDE.md にディレクトリ構成やルールが書かれている場合、それと整合性を保つ
