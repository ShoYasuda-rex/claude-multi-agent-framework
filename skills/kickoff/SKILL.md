---
name: kickoff
description: プロダクトの本質整理 + アーキテクチャ設計 + プロジェクト初期化
user_invocable: true
argument-hint: "[プロジェクト名]"
model: opus
---

# Draft Designer（プロダクト設計）

「誰の・何の課題を・どう解決するか」を整理し（→ docs/CORE.md）、
「プログラムとしてどう作るか」を設計する（→ docs/ARCHITECTURE.md）。

1つのスキルで設計の上流（Why）から下流（How）まで一気通貫で進める。

---

## 起動時の動作

### Step 0: アプリ名の確定とフォルダ作成

$ARGUMENTS があればアプリ名として使う。なければ AskUserQuestion で聞く:

> アプリの名前は？（英語のケバブケースが理想。例: habit-tracker, recipe-box）

アプリ名が決まったら:

1. カレントディレクトリに `{アプリ名}/` フォルダが**存在しない** → `mkdir -p {アプリ名}/docs` で作成し、`cd {アプリ名}` で移動
2. カレントディレクトリに `{アプリ名}/` フォルダが**存在する** → そのまま `cd {アプリ名}` で移動
3. カレントディレクトリ自体がプロジェクトフォルダ（docs/ や CLAUDE.md が既にある） → フォルダ作成はスキップ

### Step 1: モード判定

docs/CORE.md と docs/ARCHITECTURE.md の存在を確認する。

- **両方存在しない** → 新規作成モードへ
- **いずれか（または両方）存在する** → 編集モードへ

---

## たたき台の取得（新規作成モード）

CORE.md が存在しない場合、まず `docs/BRAINSTORM.md` の有無を確認する。

- **docs/BRAINSTORM.md が存在する** → 読み込んで次のステップへ進む
- **docs/BRAINSTORM.md が存在しない** → AskUserQuestion で聞く:

> ブラウザ版Claudeで作ったたたき台があれば貼って。なければ「なし」と答えて。

  - **たたき台が貼られた** → `docs/BRAINSTORM.md` に保存し、次のステップへ進む
  - **「なし」** → たたき台なしで続行（ゼロからヒアリング）

たたき台がある場合、以降のヒアリングでは**たたき台でカバー済みの項目をスキップ**し、不足項目のみ質問する。

---

## 新規作成モード

### Phase 1: CORE.md の作成（プロダクトの本質整理）

技術や実装の話には一切触れず、ビジネス・サービスとしての本質を言語化する。

#### Step 1: ヒアリング

以下の順序で AskUserQuestion を使って質問する。**1つずつ聞く**（まとめて聞かない）。
ユーザーが「わからない」「まだ決まってない」と答えたら、無理に詰めず「一旦空欄にして次へ進もう」と伝えて先に進む。

1. **誰の課題か**: 「困っている人は誰？どんな状況の人？」
2. **何に困っているか**: 「その人は今、具体的に何に困ってる？」
3. **どうなったら嬉しいか**: 「その人がどうなれば解決？理想の状態は？」
4. **なぜ今の方法ではダメか**: 「既存の解決策（競合・代替手段）の何が足りない？」
5. **やらないこと**: 「このサービスでは明確にやらないことは？」

#### Step 2: 軌道修正

ユーザーが以下に逸れたら戻す：

| 逸れた内容 | 戻し方 |
|-----------|--------|
| 技術選定・実装方法 | 「作り方は後。まず誰の何を解決するか固めよう」 |
| 機能リスト | 「機能は手段。まずユーザーの理想の状態を描こう」 |
| 収益モデル・マネタイズ | 「ビジネスモデルは後。まず価値を明確にしよう」 |
| 競合分析の深堀り | 「競合の詳細は別途。今は自分たちの立ち位置を決めよう」 |

#### Step 3: 壁打ち

ヒアリング内容をもとに、以下の観点で壁打ちする。1つずつ質問する。

- **課題の解像度**: 「それって本当に困ってること？もっと手前に本質的な課題がない？」
- **ユーザー像の絞り込み**: 「全員に届けようとしてない？最初の1人は誰？」
- **ゴールの検証可能性**: 「それって達成したかどうか、どうやってわかる？」

壁打ちで新たに見えたことがあれば、ヒアリング内容を更新する。

#### Step 4: CORE.md 出力

壁打ち完了後、CORE.md 出力フォーマットに従って docs/CORE.md を生成する。

---

### Phase 2: ARCHITECTURE.md の作成（アーキテクチャ設計）

CORE.md（Why + 体験方針）を受けて「プログラムとしてどう作るか」を設計する。

#### Step 1: 要件・仕様の確認

Phase 1 で作成した CORE.md の内容を簡潔に提示し、「この理解で合っている？」と確認する。
ズレがあれば先に修正するよう促す。

`docs/BRAINSTORM.md` があれば読み込む（技術指定・ホスティング先・外部連携などの追加コンテキストとして使う）。

#### Step 2: ヒアリング

以下の順序で AskUserQuestion を使って質問する。**1つずつ聞く**（まとめて聞かない）。
ユーザーが「わからない」「まだ決まってない」と答えたら、ベストプラクティスに基づく提案を出しつつ先に進む。

1. **技術的な制約**: 「使いたい（または使わざるを得ない）技術・プラットフォームはある？（例：Cloudflare、Vercel、Rails、React など）」
2. **ホスティング先**: 「サーバー/ホスティングはどこを使う？」
   - `Cloudflare Pages`（Recommended）
   - `Heroku`
   - `WebARENA SuiteX`（共用サーバー、SSH不可、FTPデプロイ）
   - Other で直接入力
3. **ローカル開発環境**: 「ローカル開発にDockerを使う？（Windows環境では依存関係・DB・システムライブラリの問題を一括回避できる）」
   - `Docker Compose で統一`（Recommended）
   - `使わない（ネイティブインストール）`
   - Other で直接入力
4. **データの永続化**: 「ユーザーのデータはどこに保存する？（例：ブラウザ、DB、外部サービス）」
5. **認証・権限**: 「ログイン機能は必要？ユーザーの種類（一般・管理者など）は？」
6. **外部連携**: 「外部APIやサービスとの連携はある？（例：AI API、決済、メール送信）」
7. **規模感**: 「初期のユーザー規模は？（個人利用〜数百人〜数万人）」
8. **エラー通知**: 「バックエンドのエラー通知はどうする？」
   - `Sentry`（Recommended）
   - `ログファイル監視のみ`
   - `なし（basic向け）`
   - Other で直接入力
9. **セキュリティレベル**: ヒアリング結果（認証・外部連携・規模感）から推定し、提案する
   - 認証なし＆外部連携なし → `basic` を提案
   - 認証あり or ユーザーデータ保存あり → `standard` を提案
   - 決済・金融・医療・機密個人情報を扱う → `strict` を提案
   - 提案とともに「セキュリティレベルは {推定レベル} でよい？」と確認。ユーザーが変更すればそちらを採用

#### Step 3: 軌道修正

ユーザーが以下に逸れたら戻す：

| 逸れた内容 | 戻し方 |
|-----------|--------|
| ビジネス要件の再議論 | 「要件は CORE.md で固めてある。今は作り方の設計に集中しよう」 |
| UX・体験の議論 | 「体験方針は CORE.md で固めてある。今はそれをどう実現するか考えよう」 |
| コードの詳細実装 | 「コードレベルの話は実装時に決める。今は構造の大枠を固めよう」 |
| スコープの肥大化 | 「全部盛り込みたくなるけど、最小構成で動くものを先に設計しよう」 |

#### Step 4: 設計の壁打ち

ヒアリング内容をもとに、以下の観点で壁打ちする。1つずつ質問する。

- **複雑さの検証**: 「この構成でオーバーエンジニアリングになってない？もっとシンプルにできない？」
- **体験との整合性**: 「CORE.md で定義した体験方針を、この技術構成で実現できる？ボトルネックはない？」
- **拡張性の確認**: 「将来やりたくなりそうなこと（CORE.md のスコープ外に書いてあることなど）に対して、この設計は拡張できる？」

壁打ちで新たに見えたことがあれば設計を更新する。

#### Step 5: ARCHITECTURE.md 出力

壁打ち完了後、ARCHITECTURE.md 出力フォーマットに従って docs/ARCHITECTURE.md を生成する。

#### Step 6: セキュリティレベルの反映

ヒアリングで確定したセキュリティレベルを、プロジェクトの CLAUDE.md に `security-level: {レベル}` として書き込む。
- CLAUDE.md が存在しない場合は作成する
- 既に `security-level` の記載がある場合は上書きする

#### Step 7: プロジェクト初期化

ARCHITECTURE.md の技術スタックに基づいて、コードを書き始められる状態までセットアップする。

**1. フレームワーク初期化**

技術スタックに応じた初期化コマンドを**実行する**:

| 技術スタック | コマンド |
|--|--|
| Rails | `rails new . --skip-bundle` + `bundle install` |
| Next.js | `npx create-next-app@latest .` |
| Vite (React) | `npm create vite@latest . -- --template react` |
| Cloudflare Workers | `npm create cloudflare@latest .` |
| Express | `npm init -y` + 依存インストール |
| 静的サイト（HTML/CSS/JS） | スキップ（フレームワーク不要） |
| その他 | ARCHITECTURE.md の指定に従い、ユーザーに確認しながら実行 |

既にフレームワークが初期化済み（Gemfile や package.json が存在）の場合はスキップする。

**2. 依存パッケージのインストール**

ARCHITECTURE.md の技術スタック・外部APIから必要なパッケージを特定し、インストールする:
- Ruby: `bundle add {gem名}`
- Node.js: `npm install {パッケージ名}`
- Python: `pip install {パッケージ名}`

**3. ディレクトリ構成**

ARCHITECTURE.md の「ディレクトリ構成」セクションに基づいて、必要なディレクトリを `mkdir -p` で作成する。
フレームワークが自動生成したディレクトリと重複する場合はスキップ。

**4. CLAUDE.md の生成・更新**

プロジェクトの CLAUDE.md に以下を追記する（既に存在する場合は更新）:

```markdown
# プロジェクト名

## 技術スタック
（ARCHITECTURE.md から転記。簡潔に）

## 開発コマンド
- サーバー起動: {コマンド}
- テスト: {コマンド}
- lint: {コマンド}
```

#### Step 8: 次のステップの案内

ユーザーに以下を案内する:

> プロジェクトの初期化が完了しました。`/local` でローカルサーバーを起動して、実装を始められます。

---

## 編集モード

### Step 1: 何をするか確認

AskUserQuestion で聞く:

> 何をする？

選択肢:
- CORE を見直す（誰の・何の課題）
- ARCH を見直す（技術構成）
- 初期化を続行（docs はそのまま、プロジェクトセットアップへ進む）

「初期化を続行」が選ばれた場合 → 新規作成モードの **Step 7: プロジェクト初期化** へスキップする。

---

### CORE 編集

#### Step 1: 現状確認

docs/CORE.md を読み込み、要約を提示する：
- 現在の課題定義
- ターゲットユーザー
- 提供する価値
- やらないこと

#### Step 2: 変更箇所の確認

「どこをどう見直したい？」とフリーワードで聞く。

#### Step 3: 更新

指定された箇所のみ更新して保存する。

---

### ARCH 編集

#### Step 1: 現状確認

CORE.md、docs/ARCHITECTURE.md を読み込み、要約を提示する：
- 技術スタック
- ディレクトリ構成の概要
- データモデルの概要
- API設計の概要

#### Step 2: 変更箇所の確認

「どこをどう見直したい？」とフリーワードで聞く。

#### Step 3: 更新

指定された箇所のみ更新して保存する。
セキュリティレベルが変更された場合は CLAUDE.md の `security-level` も更新する。

---

## 出力フォーマット

### docs/CORE.md

$ARGUMENTS が指定されていればプロジェクト名として使う。

```markdown
# プロジェクト名

## 誰のためのサービスか
（具体的なユーザー像。「30代」のような属性ではなく、状況・文脈で描く）
- ユーザー像1: どんな状況で、何を感じている人か
- ユーザー像2: （必要なら）

## 何に困っているか
（ユーザーが感じている課題。ユーザーの言葉で書く）
- 課題1
- 課題2

## どうなったら嬉しいか
（課題が解決された理想の状態。検証可能な形で）
- [ ] 理想状態1
- [ ] 理想状態2
- [ ] 理想状態3

## なぜ既存の方法ではダメか
（競合・代替手段と比べた時の、このサービスの存在意義）

## やらないこと
（明確にスコープ外とすること）
- xxx
- xxx

## 一言で言うと
（このサービスを1文で説明する。エレベーターピッチ）
```

### docs/ARCHITECTURE.md

$ARGUMENTS が指定されていればプロジェクト名として使う。

```markdown
# プロジェクト名 — アーキテクチャ設計

## 技術スタック

| レイヤー | 技術 | 用途 |
|---------|------|------|
| フロントエンド | xxx | xxx |
| バックエンド | xxx | xxx |
| データベース | xxx | xxx |
| ホスティング | xxx | xxx |
| 外部API | xxx | xxx |

### 選定理由
（なぜこの技術を選んだか。代替案との比較は1行程度で簡潔に）

## ディレクトリ構成

（予定するディレクトリ構成をツリー形式で記載。各ディレクトリの役割をコメントで付与）

## コンポーネント分割

（画面・機能をどう分割するか。CORE.md の体験方針と対応させて記述）

| コンポーネント | 責務 | 対応する体験方針 |
|--------------|------|------------------|
| xxx | xxx | CORE: 体験方針 |

## データモデル

（主要なデータ構造とその関係を記述）

| モデル | 主要フィールド | 用途 |
|--------|--------------|------|
| xxx | xxx | xxx |

### データフロー
（データがどこで生まれ、どこに保存され、どこで使われるかの流れ）

## API設計

（エンドポイント一覧。内部APIも外部APIも含む）

| メソッド | パス | 用途 | 認証 |
|---------|------|------|------|
| GET | /api/xxx | xxx | 要/不要 |

## 認証・権限設計

（認証方式とユーザー権限の設計。不要なら「認証なし」と記載）

## エラーハンドリング・監視

（バックエンドのエラー処理方針とエラー通知の設計）

| 項目 | 方針 |
|------|------|
| グローバルエラーハンドラ | xxx（例: Express error middleware / Rails rescue_from） |
| エラーレスポンス形式 | xxx（例: { error: { code, message } }） |
| エラー通知 | xxx（例: Sentry / ログ監視のみ / なし） |
| ログ出力 | xxx（例: 構造化ログ(JSON) / テキストログ） |

## やらないこと（技術的スコープ外）

（CORE.md の「やらないこと」を技術的に翻訳したもの）
- xxx
- xxx
```

---

## ルール

### CORE.md のルール

1. **人の課題に集中** — 技術・機能・実装の話は絶対に書かない
2. **ユーザーの言葉で書く** — 業界用語やビジネス用語を避ける
3. **状況で描く** — 属性（年齢、性別）ではなく文脈（どんな時に何を感じるか）で書く
4. **検証可能なゴール** — 「便利になる」ではなく「○○ができるようになる」
5. **短く保つ** — 1ページ以内が理想

### ARCHITECTURE.md のルール

1. **構造に集中** — コードの書き方（命名規則、コーディングスタイル）には触れない
2. **CORE.md との整合性** — 体験方針を実現できる構成であること
3. **シンプルに保つ** — 必要十分な設計。使わないかもしれないレイヤーは入れない
4. **決定と理由をセットで書く** — 「Reactを使う」だけでなく「Reactを使う。理由: xxx」
5. **短く保つ** — 2ページ以内が理想

### 共通

6. **このスキルで作るのは docs/CORE.md と docs/ARCHITECTURE.md のみ** — 実装計画は EnterPlanMode で立てる

---

## アンチパターン（これを出力してはいけない）

### CORE.md のアンチパターン

悪い例（手段を書いている）:
```
## どうなったら嬉しいか
- AIチャットボットで相談できる
- 診断結果をPDFで出力できる
- モバイル対応している
```

良い例（価値を書いている）:
```
## どうなったら嬉しいか
- [ ] 自分の強みを自分の言葉で説明できるようになる
- [ ] 「次に何をすべきか」が具体的に見えている
- [ ] 漠然としたモヤモヤが整理されて、前に進める気持ちになる
```

### ARCHITECTURE.md のアンチパターン

悪い例（実装詳細を書いている）:
```
## コンポーネント分割
- UserForm コンポーネントは useState で状態管理する
- API呼び出しは useEffect 内で fetch を使う
- エラー時は try-catch で Error Boundary に投げる
```

良い例（構造を書いている）:
```
## コンポーネント分割
| コンポーネント | 責務 | 対応する体験方針 |
|--------------|------|------------------|
| オンボーディング | 初回訪問時のユーザー情報取得 | CORE: 体験方針「全体の見通しを知る」 |
| ワークブック | 各ステップの入力・保存 | CORE: 体験方針「対話で自分を知る」 |
| 結果サマリー | 全ステップの統合ビュー | CORE: 体験方針「整理された自分を見る」 |
```

悪い例（ビジネス要件を繰り返している）:
```
## データモデル
ユーザーが自分の強みを認識できるように、強み分析テーブルを用意する。
自己肯定感が低い人でも使えるよう、優しいUIにする。
```

良い例（技術的な構造を書いている）:
```
## データモデル
| モデル | 主要フィールド | 用途 |
|--------|--------------|------|
| User | id, email, name, created_at | ユーザー管理 |
| WorkbookEntry | id, user_id, step, data(JSON) | ステップ回答の保存 |
| ChatHistory | id, user_id, messages(JSON) | AI対話履歴の保存 |
```
