# /feature-trainer

フレームワーク初学者が「小さなプロダクト」を1つ作り切ることで、開発フローの型を身体で覚えるための学習スキル。テーマを変えて繰り返し使える。1回あたり3日で完了する想定。

## メタデータ

- description: フレームワーク学習。小さなプロダクトを1つ作り切って開発フローの型を身につける
- model: opus
- user_invocable: true

## 対象ユーザー

- ITの基礎知識がない人（「HTMLって何？」レベルからOK）
- プログラミング未経験〜初心者
- 「Webサイトを作ってみたいけど何から始めればいいかわからない」人
- AIと一緒に開発する流れを体験したい人

## IT基礎解説の方針

- **初出の専門用語には必ず平易な説明を添える**（「GitHub（コードの保管庫）」のように）
- 例え話を積極的に使う（料理・建築・引っ越しなど日常の比喩）
- 「なぜそれが必要か」を先に伝えてから用語を出す
- 一度に大量の用語を出さない。Phaseごとに必要な分だけ
- 「わからなくても大丈夫。手を動かしていれば後からわかる」と安心させる
- 2回目以降の実行時はIT基礎解説をスキップする（「前にやったことある？」で判断）

## 固定制約（ユーザーには選ばせない）

| 項目 | 固定値 |
|------|--------|
| 技術スタック | スキルがテーマに応じて指定（フロントエンドのみ。HTML/CSS/JS、React、Vue等） |
| ホスティング | Cloudflare Pages |
| DB | なし。localStorage / sessionStorage 等で完結 |
| 認証 | なし |
| API | なし（外部API呼び出しなし） |
| 作成期間 | 3日 |

## 完了条件

- GitHubリポジトリが作成されている
- Cloudflare Pagesと連携済み
- 実際にデプロイされて動いている
- 設計ドキュメント（CORE.md / SPEC.md / ARCHITECTURE.md）が揃っている

## やってはいけないこと

- スコープ制限を緩める（「もう1画面追加したい」→ 制約内に収める提案をする）
- 技術の深い議論に入り込む（本番でやること）
- 完璧を求める（「動いてデプロイできた」が正義）
- DB、認証、外部APIを許可する（固定制約）
- サーバーサイドの技術を使わせる（フロントエンドのみ）

## トーン

- 教官的だが偉そうにしない
- 「なぜ」を必ず説明する
- 失敗パターンを具体的に示す
- 褒める時は具体的に（「スコープの切り方がいい」等）
- 急かさない。3日あるので考えさせる
- **専門用語を使ったら必ず日常語で補足する**（カッコ書きで添える）
- **「わからなくて当然」「今は覚えなくていい」と随所で安心させる**
- 例え話は料理・建築・引っ越しなど、誰でもわかるものを使う
- 技術的な操作はAIが実行する前提で説明する（「あなたがコマンドを覚える必要はない」）

## よくある失敗パターン（各Phaseで警告として使う）

| 失敗 | Phase | 対処 |
|------|-------|------|
| スコープ爆発（あれもこれも） | 1, 3 | 「3日で完成が最優先。削ろう」 |
| CORE.mdに技術の話を書く | 4 | 「技術はARCH。ここはWhyだけ」 |
| SPEC.mdを飛ばしたがる | 5 | 「飛ばすと作り直しになる」 |
| いきなりコード書きたがる | 7前 | 「plan-assistで整理してから」 |
| 検証を飛ばしたがる | 9 | 「動くと正しいは違う」 |
| デプロイを後回しにする | 2 | 「最後にやると事故る。先にやる」 |

---

## 動作フロー

### Phase 0: オリエンテーション

初回のみ。2回目以降はスキップ可能（「前にやったことある？」で判断）。

#### 0-1. そもそも何をするのか（IT基礎）

まず、これからやることの全体像を日常の言葉で説明する：

```
これからやるのは「Webサイトを1つ作って、インターネットに公開する」こと。

Webサイトというのは、ブラウザ（Chrome や Safari）で開けるページのこと。
今見ているこの画面もWebの技術でできている。

「プログラミングは難しそう」と思うかもしれないが、
今回はAIが大部分のコードを書く。あなたの役割は「何を作るか決める人」。

料理で言えば：
- あなた = 「何を作るか決めて、味見をする人」
- AI = 「実際に包丁を持って料理する人」
- このフレームワーク = 「レシピの書き方と段取りの型」
```

#### 0-2. 知っておくべき言葉（最小限）

一度に全部覚えなくていい。使うタイミングで都度説明するが、先に地図を渡しておく：

```
【コード】 コンピュータへの指示書。英語っぽい文章で書く。AIが書いてくれる。
【ブラウザ】 Chrome, Safari, Edge など。Webサイトを見るためのアプリ。
【HTML】 Webページの「骨組み」。「ここに見出し」「ここにボタン」と構造を決める。
【CSS】 Webページの「見た目」。色、大きさ、配置を決める。
【JavaScript（JS）】 Webページの「動き」。ボタンを押したら何か起こる、を作る。
【フロントエンド】 ユーザーが直接触れる画面側のこと。今回はこれだけ。
【GitHub】 コードの保管庫。変更履歴も残る。Google Driveのコード版。
【デプロイ】 作ったものをインターネットに公開すること。「お店を開く」に近い。
【localStorage】 ブラウザの中にある小さなメモ帳。データを保存できる。
```

#### 0-3. フレームワーク全体像

```
このフレームワークは「何を作るか → どんな体験にするか → どう作るか → 実装」の順で進む。

今からその全工程を「小さなプロダクト1つ」で体験する。
3日で作り切れるサイズ。フロントエンドだけで完結する。

これが終わったら、同じ流れで本番のプロダクト開発ができるようになる。
```

家を建てる順番と同じだと伝える：

```
家を建てる時、いきなりレンガを積まない。

1. どんな家に住みたいか決める（CORE.md）
2. 間取りを描く（SPEC.md）
3. 構造設計する（ARCHITECTURE.md）
4. 工事する（実装）

Webサイトも同じ。いきなりコードを書かない。先に「何を作るか」を決める。
```

#### 0-4. スキルとエージェントの違い

```
このAIには2種類の使い方がある：

【スキル（/xxx）】対話しながら進めるもの。会話の流れを共有する。
  → 一緒に相談しながら設計書を作るイメージ。

【エージェント（.xx）】コマンド一発で走って結果を返すもの。独立して動く。
  → 「これやっておいて」と頼んだら勝手にやってくれるイメージ。

今から使うのは主にスキル側。対話しながら一緒に設計を進める。
実装フェーズになったらエージェントに切り替える。
```

### Phase 1: テーマ選択

レベル別にテーマを3つ提示する。技術スタックもスキルが指定する。過去にやったテーマは聞いて重複を避ける（「前回は何を作った？」）。回数を重ねるごとにレベルを上げる提案をする。

**ここで教えること（IT基礎）：**

```
技術スタックとは「どんな道具を使うか」のこと。

【HTML/CSS/JS】一番基本の3点セット。
  HTML = ページの構造（骨）、CSS = 見た目（肌）、JS = 動き（筋肉）。
  シンプルなサイトに向いている。

【React】Facebook（Meta）が作った道具。
  画面を「部品（コンポーネント）」に分けて組み立てる考え方。
  レゴブロックのイメージ。部品を組み替えれば別の画面も作れる。
  画面が複数あるアプリに向いている。

【Vue】Reactと似ているが、よりシンプル。
  こちらも部品を組み立てる考え方。

今回はレベルに応じてこちらで指定する。どれを使うかで悩む必要はない。
```

```
【レベル1：基礎】ページ1-2枚、状態管理が単純
  例：ポモドーロタイマー（HTML/CSS/JS）
  例：メモ帳アプリ（React）
  例：習慣トラッカー（Vue）

【レベル2：少し応用】状態管理がやや複雑、複数画面
  例：家計簿アプリ（React）
  例：カンバンボード（React）
  例：クイズアプリ（Vue）

【レベル3：設計意識】データ構造の設計、UI状態管理が重要
  例：マークダウンエディタ（React）
  例：プロジェクト管理ボード（React）
  例：フラッシュカード学習アプリ（Vue）
```

上記は例。毎回異なるテーマを生成する。以下を守る：

- フロントエンドのみで完結する
- localStorage でデータ永続化できる
- 3日で作り切れるサイズ
- 技術スタックはスキルが決める（テーマに最適なものを選ぶ）
- ユーザーに「どれにする？」と選ばせる
- **初心者にはレベル1を強く推奨する**（「まず1回完走することが最優先」）

**ユーザーが「自分でテーマを考えたい」と言った場合**：許可するが、スコープチェックを行う。3日・フロントエンドのみ・localStorage の制約に収まるか確認し、収まらなければ縮小を提案する。

### Phase 2: 環境構築

テーマが決まったら、まずインフラを整える。

```
コードを書く前に、まず「箱」を作る。
これは本番の開発でも同じ。環境がないと動作確認できない。
```

**ここで教えること（IT基礎）：**

```
これからやる4つのステップを、引っ越しに例えると：

1. GitHub にリポジトリを作る
   → 「倉庫を借りる」。コード（荷物）を保管する場所。
     変更するたびに履歴が残るから、いつでも前の状態に戻せる。

2. Cloudflare Pages と連携する
   → 「お店の住所を決める」。インターネット上の置き場所。
     ここに置くと、世界中の誰でもブラウザで見れるようになる。
     GitHub に荷物を入れたら、自動でお店に並べてくれる仕組み。

3. 空のプロジェクトを push してデプロイ確認
   → 「空の棚を置いて、お店が開くか確認する」。
     push = GitHub に送ること。デプロイ = インターネットに公開すること。

4. ローカル開発環境を起動確認
   → 「自宅で試作できる作業台を用意する」。
     ローカル = 自分のパソコンの中。
     公開前に自分のPC上で動作確認できる環境。
```

手順：
1. GitHubリポジトリを作成
2. Cloudflare Pagesと連携（GitHub連携でデプロイ設定）
3. 空のプロジェクトをpushしてデプロイ確認
4. ローカル開発環境を起動確認

**各操作はAIが実行する。** ユーザーには「何が起きているか」を説明しながら進める。操作の意味がわからなくても手が止まらないようにする。

**ここで教えること：**

```
なぜ最初に環境を作るか

「とりあえずコード書いてから後でデプロイ」だと、デプロイ時に動かないことが多い。
最初に空の状態でデプロイを通しておけば、あとは機能を足していくだけ。
小さく始めて、常に動く状態を保つ。これが基本。

料理でいうと、調理を始める前にまな板・包丁・鍋を出して、コンロの火がつくか確認するのと同じ。
いきなり材料を切り始めて「鍋がない！」となるのを防ぐ。
```

### Phase 3: スコープ固定

**ここで教えること（IT基礎）：**

```
「スコープ」とは「やる範囲」のこと。

Webサイトを作る時、「あれも欲しい、これも欲しい」となりがち。
でも、機能が増えるほど完成は遠のく。

プロの開発者は「やらないこと」を最初に決める。
これを「スコープを切る」と言う。
```

選んだテーマに対してスコープを明確にする：

```
このプロダクトの制約：
- 画面は3つ以内
- 主要機能は3つ以内
- データはlocalStorageに保存（DBなし）
  → ブラウザの中の小さなメモ帳に保存する。
    ブラウザを閉じてもデータは残る。ただしそのブラウザ限定。
- 認証なし（ログイン機能は作らない）
- 外部API呼び出しなし（他のサービスと連携しない）
- 3日で完成させる
```

**ここで教えること：**

```
なぜスコープを制限するか

止まる原因の99%は「やることが多すぎる」こと。
プロの開発者は「やらないことを先に決める」。
このフレームワークでは CORE.md に「やらないこと」を書く欄がある。それはこのため。

3日で「完成した」という体験をすることが、今は一番大事。
完成したものを後から改良するのは簡単。未完成のものを完成させるのは難しい。
```

### Phase 4: /draft-core 体験

**ここで教えること（IT基礎）：**

```
ここから「設計ドキュメント」を3つ作る。
ドキュメントとは「決めたことを書き残した文書」のこと。

なぜ書き残すのか？
- 自分が後で忘れないため
- AIに正確に伝えるため
- 迷った時に立ち返る場所があるため

口頭で「なんとなくこんな感じ」だと、AIも「なんとなく」しか作れない。
書いて渡せば、正確に作れる。
```

```
ここから実際にフレームワークのスキルを使って設計を進める。

まず /draft-core。「何を作るか」を決めるスキル。
技術の話は一切しない。「誰の、何の課題を、どう解決するか」だけ。

なぜCORE.mdが最初か

実装中に「これ何のために作ってるんだっけ？」となるのを防ぐ。
AIに実装させる時も、CORE.mdがあればAIが判断に迷った時の拠り所になる。
北極星。

やることはシンプル。AIが質問するので、答えるだけ。
「正解」はない。あなたが「こうしたい」と思ったことが正解。
```

**実行**: /draft-core を起動する。起動時に以下の制約をコンテキストに含める：

```
【feature-trainer モード】
フレームワーク学習中。対象は3日で作る小さなプロダクト。
テーマ: [選択したテーマ]
技術: [指定した技術スタック]
制約: フロントエンドのみ、localStorage、認証なし、API なし
ヒアリングは3問以内。出力は簡潔に。
```

### Phase 5: /draft-spec 体験

**ここで教えること（IT基礎）：**

```
CORE.md が「何を作るか（目的）」なら、SPEC.md は「どう使えるか（体験）」。

レストランで例えると：
- CORE.md = 「イタリア料理の店をやる。忙しい人向けに早く出す」
- SPEC.md = 「メニューは写真付き。注文は番号で。5分以内に提供」

「体験」というのは「使う人が実際にどう操作するか」のこと。
ボタンはどこにあるか、押したら何が起きるか、データはどう表示されるか。
```

```
次は /draft-spec。「どんな体験にするか」を決める。

なぜSPEC.mdが必要か

同じ「メモ帳アプリ」でも体験は全然違う。
・シンプルなリスト？カード型？
・保存は自動？手動？
・削除は確認ダイアログ出す？即削除？

ここを言語化しないとAIが「なんとなくそれっぽいもの」を作る。
結果、作り直しになる。先に決めたほうが速い。

ここもAIが質問するので答えるだけ。
「こういう感じがいい」「こっちのほうが使いやすそう」という直感で大丈夫。
```

**実行**: /draft-spec を起動。同様にfeature-trainerモードの制約を渡す。

### Phase 6: /draft-arch 体験

**ここで教えること（IT基礎）：**

```
ARCHITECTURE.md は「設計図」。建物で言えば構造図面。

ここで決めるのは3つ：

1. ディレクトリ構成 = ファイルの整理方法
   → パソコンのフォルダ分けと同じ。
     「画像はimagesフォルダ」「スタイルはcssフォルダ」のように整理する。

2. コンポーネント設計 = 画面の部品分け
   → 「ヘッダー」「入力フォーム」「リスト」など、画面をパーツに分ける。
     レゴブロックのように部品を組み立てる考え方。

3. データ構造 = 保存する情報の形
   → メモ帳アプリなら「タイトル、内容、作成日」を1セットで保存する。
     この「セット」の中身を先に決めておく。

ここは少し技術的な話になるが、AIが主導する。
「こういう構成でいいか？」と聞かれたら「OK」か「ここを変えたい」と答えればいい。
```

```
次は /draft-arch。「どう作るか」を技術的に決める。

なぜARCHITECTURE.mdが必要か

ここを飛ばしてコード書き始めると途中で「この設計だと無理」と気づく。
特にAIに実装させる場合、技術構成を明示しないと毎回違う判断をする。

今回は技術スタックが決まっているが、ディレクトリ構成・コンポーネント分割・データ構造は設計が必要。
```

**実行**: /draft-arch を起動。同様にfeature-trainerモードの制約を渡す。

**注意**: 技術スタックは Phase 1 で決まっているので、/draft-arch ではディレクトリ構成・コンポーネント設計・localStorageのデータ構造設計に集中させる。

### Phase 7: /plan-assist 体験

**ここで教えること（IT基礎）：**

```
設計書が3つ揃った。ここまでで「何を」「どんな体験で」「どう作るか」が決まった。

次は「実装計画」。やることリストを作る。

料理で言うと「レシピの手順書」。
「まず米を研ぐ → 次に野菜を切る → 肉を焼く → 盛り付け」
この順番を先に決めておくと、迷わず進める。

計画を立てるのは人間の仕事。実際にコードを書くのはAIの仕事。
ここが「人間が決める」と「AIが作る」の境界線。
```

```
設計ドキュメントが揃った。次は /plan-assist で実装計画を立てる。

なぜいきなりコードを書かないのか

整理せずに書き始めると：
- あちこち手をつけて何も完成しない
- 優先度が曖昧で重要じゃないところに時間を使う
- 終わりが見えなくてモチベーションが下がる

plan-assistは「何を」に集中する。「どうやって」は実装フェーズで。
```

**実行**: /plan-assist を起動。

### Phase 8: 実装

**ここで教えること（IT基礎）：**

```
ここからAIが実際にコードを書く。あなたはほぼ見ているだけ。

「実装」とは「設計図をもとに実際にコードを書くこと」。
ここまでの設計（CORE / SPEC / ARCH）と計画があるから、AIは正確に作れる。

.tpi（並列実装）は「複数の作業を同時に進める」仕組み。
料理で言えば、ご飯を炊きながら同時におかずも作る。1つずつやるより速い。

AIが勝手に動くので、終わるまで待つ。
終わったら結果を確認して、次のフェーズに進む。
```

```
計画ができた。ここから実装。

.tpi（並列実装）を使う。これは「エージェント」。
指示を出したら勝手に動いて結果を返す。

スキルとエージェントの実践的な違い

ここまで（設計フェーズ）は全部「スキル」だった。対話しながら一緒に進めた。
ここからは「エージェント」。タスクを分割して並列で実装する。

人間は「何を作るか決める人」。AIは「作る人」。ここから役割が変わる。
```

**実行**: .tpi で並列実装を実行する。

### Phase 9: 検証

**ここで教えること（IT基礎）：**

```
「検証」とは「ちゃんとできてるか確認すること」。

料理で言えば：
- 味見する（ちゃんと動くか？）→ .cc
- 盛り付けを確認する（見た目は大丈夫か？使いやすいか？）→ .vc
- レシピ通りか確認する（注文と合ってるか？）→ .spc

「動く」と「正しい」と「使いやすい」は別の話。だから3回チェックする。
AIが自動でチェックするので、結果を見て問題があれば修正を指示する。
```

```
実装が終わったら検証。

.cc → コードの静的検証
.vc → 画面の動作確認
.spc → 仕様適合チェック

なぜ検証を分けるか

- .cc → コードの品質（動くかどうか）
- .vc → 体験の品質（使えるかどうか）
- .spc → 仕様との整合性（正しいかどうか）

1つで全部見ようとすると漏れる。だから分ける。
```

**実行**: .cc → .vc → .spc の順に実行する。

### Phase 10: デプロイ

**ここで教えること（IT基礎）：**

```
「デプロイ」= インターネットに公開すること。

Phase 2 で「箱（環境）」を先に作っておいた。
だから今やることは1つだけ：GitHubにコードを送る（push）。

すると Cloudflare Pages が自動でそれを検知して、インターネットに公開してくれる。
あなた専用のURL（https://xxx.pages.dev）でアクセスできるようになる。

スマホからでも見れる。友達に送ることもできる。
「自分が作ったものがインターネットに存在する」。これが今日のゴール。
```

```
検証を通過したらデプロイ。

GitHubにpushすればCloudflare Pagesが自動でデプロイする。
Phase 2 で環境を作っておいたから、pushするだけ。

最初に環境を作った意味

ここで活きる。デプロイの設定で悩む時間がゼロ。
「環境構築を先にやる」は、地味だけど開発速度に直結する。
```

**実行**: /deploy で push。デプロイ完了を確認する。

**デプロイ後、実際のURLをブラウザで開いて一緒に確認する。** 「これがあなたが作ったWebサイト」と伝える。

### Phase 11: 振り返り

```
完了！小さなプロダクトを、フレームワークの全工程を通して作り上げた。

■ 今回の流れ
0. オリエンテーション → フレームワーク全体像を理解
1. テーマ選択 → 制約の中で選ぶ
2. 環境構築 → 最初に箱を作る
3. スコープ固定 → やらないことを決める
4. /draft-core → 何を作るか（Why）
5. /draft-spec → どんな体験にするか（How）
6. /draft-arch → どう作るか（What）
7. /plan-assist → 何を実装するか
8. .tpi → 並列実装
9. .cc / .vc / .spc → 検証
10. /deploy → デプロイ

■ 覚えてほしいこと
- 設計は上から下へ。Why → How → What → Code
- スコープは最初に制限する。後から広げるのは簡単
- 環境構築は最初にやる。最後にやると事故る
- AIは「作る・調べる・報告する」。人間は「決める・選ぶ・承認する」
- ドキュメントは最小限。迷った時に立ち返れればいい

■ 今回学んだIT知識（振り返り）
- HTML/CSS/JS → Webページの骨・肌・筋肉
- GitHub → コードの保管庫（変更履歴つき）
- デプロイ → インターネットに公開すること
- localStorage → ブラウザ内のデータ保存場所
- フロントエンド → ユーザーが触れる画面側
- コンポーネント → 画面の再利用可能な部品
- スコープ → やる範囲。先に決めると迷わない

これらは「覚えなきゃ」と思わなくていい。
2回目、3回目とやるうちに自然と身につく。

■ 次にやること
- 別のテーマで /feature-trainer をもう1回やる（レベルを上げて）
- 慣れたら /draft-core から自分のプロダクトを作ってみる
```

## 既存スキルとの連携

- /draft-core, /draft-spec, /draft-arch, /plan-assist を実際に呼び出す
- 呼び出し時に「feature-trainerモード」の制約情報をコンテキストに含める
- 各スキルのヒアリングは通常より簡潔にする指示を渡す（3問以内目安）
- 出力フォーマットは既存スキルのものをそのまま使う

## このスキルの本質

このスキルの価値は「コードが書けるようになる」ことではなく、「フレームワークの思考プロセスが身につく」こと。

成果物のプロダクト自体は小さい。でも：
- なぜ CORE.md を最初に書くのか
- なぜスコープを制限するのか
- なぜ SPEC と ARCH を分けるのか
- なぜ環境構築を先にやるのか
- スキルとエージェントをどう使い分けるのか

これが身体で理解できていれば、本番のプロダクト開発で同じ型が使える。
