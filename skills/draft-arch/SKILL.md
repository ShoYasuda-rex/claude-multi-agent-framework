---
name: draft-arch
description: 実装前のアーキテクチャ設計
user_invocable: true
disable-model-invocation: true
argument-hint: "[プロジェクト名 または 要件ドキュメントのパス]"
---

# Arch Designer（アーキテクチャ設計）

SPEC.md（How）を受けて「プログラムとしてどう作るか」を設計するスキル。
実装前に技術的な全体像を固める。出力は docs/ARCHITECTURE.md。

---

## 前提

- 通常モード: SPEC.md が存在すること（なければ「先に /spec-draft でサービス仕様を整理しよう」と伝えて終了）
- 通常モード: CORE.md も存在すれば参照する（なくても進行可）
- インポートモード: SPEC.md / CORE.md がなくてもインポートドキュメントがあれば続行可能

---

## 起動時の動作

まず $ARGUMENTS がファイルパスかどうかを判定する。

**ファイルパス判定:** $ARGUMENTS が以下のいずれかに該当すればファイルパスとして扱う:
- 拡張子が `.md` / `.txt` / `.pdf` で終わる
- パス区切り（`/` または `\`）を含む

- **ファイルパスである** → インポートモードへ
- **ファイルパスでない** → 以下の通常フローへ（$ARGUMENTS はプロジェクト名として扱う）

1. CORE.md があれば読み込む
2. SPEC.md を読み込み、体験設計を把握する
3. カレントディレクトリの docs/ARCHITECTURE.md の存在を確認する
   - **存在しない** → 新規作成モードへ
   - **存在する** → 編集モードへ

---

## インポートモード

$ARGUMENTS がファイルパスと判定された場合に適用。

### Step 1: ドキュメント読み込み
- Read ツールで $ARGUMENTS のファイルを読み込む
- 読み込み失敗時は「ファイルが見つからなかった。パスを確認して」と伝えて終了
- CORE.md / SPEC.md が存在すればそれも併せて読み込む（なくても続行可）

### Step 2: 内容の抽出・整理
- ドキュメントから、出力フォーマットの各セクションに該当する情報を抽出・整理する:
  - 技術スタック
  - ディレクトリ構成
  - コンポーネント分割
  - データモデル
  - API設計
  - 認証・権限設計
  - やらないこと（技術的スコープ外）
  - セキュリティレベル（認証・決済・個人情報の有無から推定: basic / standard / strict）
- 抽出結果をチャット上に提示:「持ち込みドキュメントからこう読み取りました」

### Step 3: 不足項目のヒアリング
- 出力フォーマットの全セクションを照合し、カバーされていない項目を特定
- 不足項目のみ AskUserQuestion でヒアリング（カバー済み項目はスキップ）
- ユーザーが「それでいい」と言えばそのまま進む

### Step 4: 壁打ち
- 新規作成モードと同じ壁打ちを行う（複雑さの検証・体験との整合性・拡張性の確認）
- 壁打ちで新たに見えたことがあれば設計を更新する

### Step 5: 確認
- 最終的な整理結果を提示し、「これで合ってる？」と確認

### Step 6: 出力
- 出力フォーマットに従って docs/ARCHITECTURE.md を生成する

### Step 7: セキュリティレベルの反映
- 推定・確認したセキュリティレベルを、プロジェクトの CLAUDE.md に `security-level: {レベル}` として書き込む
- CLAUDE.md が存在しない場合は作成する
- 既に `security-level` の記載がある場合は上書きする

---

## 新規作成モード

### Step 1: 要件・仕様の確認

CORE.md と SPEC.md の内容を簡潔に提示し、「この理解で合っている？」と確認する。
ズレがあれば先に修正するよう促す。

### Step 2: ヒアリング

以下の順序で AskUserQuestion を使って質問する。**1つずつ聞く**（まとめて聞かない）。
ユーザーが「わからない」「まだ決まってない」と答えたら、ベストプラクティスに基づく提案を出しつつ先に進む。

1. **技術的な制約**: 「使いたい（または使わざるを得ない）技術・プラットフォームはある？（例：Cloudflare、Vercel、Rails、React など）」
2. **ホスティング先**: 「サーバー/ホスティングはどこを使う？」
   - `Cloudflare Pages`（Recommended）
   - `Heroku`
   - `WebARENA SuiteX`（共用サーバー、SSH不可、FTPデプロイ）
   - Other で直接入力
3. **データの永続化**: 「ユーザーのデータはどこに保存する？（例：ブラウザ、DB、外部サービス）」
4. **認証・権限**: 「ログイン機能は必要？ユーザーの種類（一般・管理者など）は？」
5. **外部連携**: 「外部APIやサービスとの連携はある？（例：AI API、決済、メール送信）」
6. **規模感**: 「初期のユーザー規模は？（個人利用〜数百人〜数万人）」
7. **セキュリティレベル**: ヒアリング結果（認証・外部連携・規模感）から推定し、提案する
   - 認証なし＆外部連携なし → `basic` を提案
   - 認証あり or ユーザーデータ保存あり → `standard` を提案
   - 決済・金融・医療・機密個人情報を扱う → `strict` を提案
   - 提案とともに「セキュリティレベルは {推定レベル} でよい？」と確認。ユーザーが変更すればそちらを採用

### Step 3: 軌道修正

ユーザーが以下に逸れたら戻す：

| 逸れた内容 | 戻し方 |
|-----------|--------|
| ビジネス要件の再議論 | 「要件は CORE.md で固めてある。今は作り方の設計に集中しよう」 |
| UX・体験の議論 | 「体験設計は SPEC.md で固めてある。今はそれをどう実現するか考えよう」 |
| コードの詳細実装 | 「コードレベルの話は実装時に決める。今は構造の大枠を固めよう」 |
| スコープの肥大化 | 「全部盛り込みたくなるけど、最小構成で動くものを先に設計しよう」 |

### Step 4: 設計の壁打ち

ヒアリング内容をもとに、以下の観点で壁打ちする。1つずつ質問する。

- **複雑さの検証**: 「この構成でオーバーエンジニアリングになってない？もっとシンプルにできない？」
- **体験との整合性**: 「SPEC.md で定義した体験フローを、この技術構成で実現できる？ボトルネックはない？」
- **拡張性の確認**: 「将来やりたくなりそうなこと（CORE.md のスコープ外に書いてあることなど）に対して、この設計は拡張できる？」

壁打ちで新たに見えたことがあれば設計を更新する。

### Step 5: 出力

壁打ち完了後、出力フォーマットに従って docs/ARCHITECTURE.md を生成する。

### Step 6: セキュリティレベルの反映

ヒアリングで確定したセキュリティレベルを、プロジェクトの CLAUDE.md に `security-level: {レベル}` として書き込む。
- CLAUDE.md が存在しない場合は作成する
- 既に `security-level` の記載がある場合は上書きする

---

## 編集モード

### Step 1: 現状確認

CORE.md、SPEC.md、docs/ARCHITECTURE.md を読み込み、要約を提示する：
- 技術スタック
- ディレクトリ構成の概要
- データモデルの概要
- API設計の概要

### Step 2: 変更箇所の確認

「どこをどう見直したい？」とフリーワードで聞く。

### Step 3: 更新

指定された箇所のみ更新して保存する。
セキュリティレベルが変更された場合は CLAUDE.md の `security-level` も更新する。

---

## 出力フォーマット

docs/ARCHITECTURE.md は以下のフォーマットで生成する。$ARGUMENTS が指定されていればプロジェクト名として使う。

```markdown
# プロジェクト名 — アーキテクチャ設計

## 技術スタック

| レイヤー | 技術 | 用途 |
|---------|------|------|
| フロントエンド | xxx | xxx |
| バックエンド | xxx | xxx |
| データベース | xxx | xxx |
| ホスティング | xxx | xxx |
| 外部API | xxx | xxx |

### 選定理由
（なぜこの技術を選んだか。代替案との比較は1行程度で簡潔に）

## ディレクトリ構成

（予定するディレクトリ構成をツリー形式で記載。各ディレクトリの役割をコメントで付与）

## コンポーネント分割

（画面・機能をどう分割するか。SPEC.md の体験フローと対応させて記述）

| コンポーネント | 責務 | 対応する体験フロー |
|--------------|------|------------------|
| xxx | xxx | SPEC: ステップN |

## データモデル

（主要なデータ構造とその関係を記述）

| モデル | 主要フィールド | 用途 |
|--------|--------------|------|
| xxx | xxx | xxx |

### データフロー
（データがどこで生まれ、どこに保存され、どこで使われるかの流れ）

## API設計

（エンドポイント一覧。内部APIも外部APIも含む）

| メソッド | パス | 用途 | 認証 |
|---------|------|------|------|
| GET | /api/xxx | xxx | 要/不要 |

## 認証・権限設計

（認証方式とユーザー権限の設計。不要なら「認証なし」と記載）

## やらないこと（技術的スコープ外）

（CORE.md の「やらないこと」を技術的に翻訳したもの）
- xxx
- xxx
```

---

## ルール

1. **構造に集中** — コードの書き方（命名規則、コーディングスタイル）には触れない
2. **SPEC.md との整合性** — 体験フローを実現できる構成であること
3. **シンプルに保つ** — 必要十分な設計。使わないかもしれないレイヤーは入れない
4. **決定と理由をセットで書く** — 「Reactを使う」だけでなく「Reactを使う。理由: xxx」
5. **短く保つ** — 2ページ以内が理想
6. **このスキルで作るのは docs/ARCHITECTURE.md のみ** — 実装計画は /plan-assist、実装は EnterPlanMode

## アンチパターン（これを出力してはいけない）

悪い例（実装詳細を書いている）:
```
## コンポーネント分割
- UserForm コンポーネントは useState で状態管理する
- API呼び出しは useEffect 内で fetch を使う
- エラー時は try-catch で Error Boundary に投げる
```

良い例（構造を書いている）:
```
## コンポーネント分割
| コンポーネント | 責務 | 対応する体験フロー |
|--------------|------|------------------|
| オンボーディング | 初回訪問時のユーザー情報取得 | SPEC: ステップ1「全体の見通しを知る」 |
| ワークブック | 各ステップの入力・保存 | SPEC: ステップ2「対話で自分を知る」 |
| 結果サマリー | 全ステップの統合ビュー | SPEC: ステップ3「整理された自分を見る」 |
```

悪い例（ビジネス要件を繰り返している）:
```
## データモデル
ユーザーが自分の強みを認識できるように、強み分析テーブルを用意する。
自己肯定感が低い人でも使えるよう、優しいUIにする。
```

良い例（技術的な構造を書いている）:
```
## データモデル
| モデル | 主要フィールド | 用途 |
|--------|--------------|------|
| User | id, email, name, created_at | ユーザー管理 |
| WorkbookEntry | id, user_id, step, data(JSON) | ステップ回答の保存 |
| ChatHistory | id, user_id, messages(JSON) | AI対話履歴の保存 |
```
