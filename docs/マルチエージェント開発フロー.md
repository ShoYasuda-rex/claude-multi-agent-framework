# Claude Code マルチエージェント開発フロー

## このドキュメントについて

**目的**: 個人開発で、一定の品質を保ちながら爆速開発するためのフレームワーク

**前提**:
- 個人開発・小規模プロジェクト向け
- Web / モバイルアプリ
- テストコードは原則書かない。壊れたら致命的な箇所（決済・認証等）だけ、人間が日本語で指定して自動生成する
- 品質担保はエージェントによる静的検証・動的検証で代替し、重要箇所のみE2Eテストで補強
- アジャイル的に回す（仕様は育てるもの）

**思想**:

要件は変わる。実際に使ってみて、変わる。だから仕様は固めない。

| ドキュメント | 役割 | スタンス |
|-------------|------|----------|
| CORE.md | 変わらない本質 | 最小限。「誰の何を解決するか」だけ |
| SPEC.md | 体験の方針 | やりながら育てる。現状の方針 |
| ARCHITECTURE.md | 技術構成 | やりながら育てる。現状の方針 |

- **CORE.md は北極星** — 実装中に迷ったら立ち返る場所。AIが判断に迷った時の拠り所
- **SPEC/ARCH は方針** — 「今こうしようとしてる」を書く。長い仕様書は作らない
- **最初はモックアップ** — 動くものを作ってから育てる。最初から完璧を目指さない
- **入れすぎない** — ドキュメントが長くなったら、それは書きすぎのサイン

**このフレームワークが存在する理由**:

AI導入で最初にやるべきはツール選びではなく、技術標準の定義と開発ルールの固定化。このフレームワークはその土台を提供する。

**人間とAIの責任分界**:

| 判断 | 誰が | どこで |
|------|------|--------|
| 何を作るか | 人間 | `/draft-core` の対話で決める |
| どんな体験にするか | 人間 | `/draft-spec` の対話で決める |
| どう作るか（技術選定） | 人間 | `/draft-arch` の対話で決める |
| 何を実装するか | 人間 | `/plan-assist` で整理して指示 |
| コードの実装 | AI | EnterPlanMode / `.tpi` |
| 画面の動作確認 | AI | `.vc` でブラウザ検証 |
| どこをテストで守るか | 人間 | `/test-assist` で日本語指定 |
| コードの検証・監査 | AI | `.cc` / `.tck` 等 |
| 監査結果への対応 | 人間 | 修正するか許容するか判断 |
| デプロイの実行 | 人間 | `/deploy` / `/deploy safe` で承認 |

**原則**: AIは「作る・調べる・報告する」。人間は「決める・選ぶ・承認する」。

**Tip**: `/draft-core` `/draft-spec` `/draft-arch` は対話が多いため、Cursorでの実行も推奨。

---

## クイックスタート

### 1. 導入

エージェント・スキルファイルを配置：

```
~/.claude/
├── agents/
│   ├── code-checker.md
│   ├── audit-code-checker.md
│   ├── audit-spec-checker.md
│   ├── audit-security-checker.md
│   ├── audit-architecture-checker.md
│   ├── visual-checker.md
│   ├── test-runner.md
│   ├── pre-safe-checker.md
│   └── log-checker.md
└── skills/
    ├── draft-core/
    │   └── SKILL.md
    ├── draft-spec/
    │   └── SKILL.md
    ├── draft-arch/
    │   └── SKILL.md
    ├── plan-assist/
    │   └── SKILL.md
    ├── deploy/
    │   └── SKILL.md
    ├── backup/
    │   └── SKILL.md
    ├── rollback/
    │   └── SKILL.md
    ├── gen-arch/
    │   └── SKILL.md
    ├── save-issue/
    │   └── SKILL.md
    ├── load-issues/
    │   └── SKILL.md
    ├── save-memo/
    │   └── SKILL.md
    ├── load-memos/
    │   └── SKILL.md
    ├── save-plan/
    │   └── SKILL.md
    ├── load-plans/
    │   └── SKILL.md
    ├── test-assist/
    │   └── SKILL.md
    ├── full-auto-team/
    │   └── SKILL.md
    ├── guide/
    │   └── SKILL.md
    ├── ops-check/
    │   └── SKILL.md
    ├── research-team/
    │   └── SKILL.md
    ├── market-team/
    │   └── SKILL.md
    └── local/
        └── SKILL.md
```

### 2. 設計（新規プロジェクトの場合）

```bash
# 何を作るか決める
/draft-core
/draft-spec
/draft-arch
```

→ `docs/CORE.md`, `docs/SPEC.md`, `docs/ARCHITECTURE.md` が生成される

要件定義書がある場合:

```bash
# 要件定義書のパスを渡してインポート
/draft-core ./要件定義書.md
/draft-spec
/draft-arch ./要件定義書.md
```

**ポイント**: 全部入れない。CORE.md は特に最小限に（変わらない本質だけ）

### 3. 実装計画

```bash
/plan-assist
```

→ 「何を実装するか」を対話で整理し、そのまま実装フローへ

### 4. モックアップ作成 → 初期化

```bash
# まず動くものを作る（.tpi で並列実装）
.tpi

# 動いたら初期化してバックアップ
/init
/backup
```

→ `CLAUDE.md` が生成され、初期状態がgitにコミットされる

### 5. 開発開始

普通に実装。以下のコマンドで品質担保：

| やりたいこと | コマンド |
|-------------|---------|
| **何をすればいいかわからない** | **`/guide`** |
| 変更前に影響範囲を調査 | `.sc` |
| 実装後に静的検証 | `.cc` |
| 仕様適合チェック | `.spc` |
| 動作・UI検証 | `.vc` |
| コード全体監査 | `.cod` |
| セキュリティ監査 | `.sec` |
| アーキテクチャ設計監査 | `.arc` |
| 本番ログ診断 | `.log` |
| 並列実装 | `.tpi` |
| 統合監査（Agent Teams） | `.tck` |
| クイックプッシュ | `/deploy` |
| 安全にプッシュ | `/deploy safe` |
| 現状をgitにバックアップ | `/backup` |
| バックアップから復元 | `/rollback` |
| テストコード自動生成 | `/test-assist` |
| テスト実行 | `.test` |
| アーキテクチャドキュメント生成 | `/gen-arch` |
| 課題・改善点を記録 | `/save-issue` |
| ためた課題を調査・実装 | `/load-issues` |
| メモを即記録 | `/save-memo` |
| メモをまとめてエクスポート | `/load-memos` |
| 計画を保存 | `/save-plan` |
| 保存した計画を実行 | `/load-plans` |
| 3視点で統合調査（UX・コード・競合） | `/research-team` |
| Go-to-Market戦略調査（訴求・チャネル・競合マーケ） | `/market-team` |
| ローカルサーバー起動 | `/local` |

---

## 概要

仕様駆動開発をベースとした開発フレームワーク。要件定義書から本質を抽出し、最小限のドキュメントで開発を進める。

---

## 開発フロー全体像

```
【起点】
要件定義書（依頼書・企画書・アイデアメモなど）
    ↓ インポートモードで抽出

【上流（本質の抽出）】
1. /draft-core → docs/CORE.md（変わらない本質だけ）
2. /draft-spec → docs/SPEC.md（体験の方針）
3. /draft-arch → docs/ARCHITECTURE.md（技術構成）
4. /plan-assist → 実装計画
5. .sc → 影響範囲調査

【下流（実装・検証）】
6. .tpi → 並列実装
7. .cc → 静的検証
8. .spc → 仕様適合チェック
9. .vc → 動的検証
10. /deploy or /deploy safe → コミット＆プッシュ

随時: .cod → コード全体監査
随時: .sec → セキュリティ監査
随時: .tck → 統合監査（Agent Teams）
随時: /backup → gitバックアップ
随時: /gen-arch → docs/current/ にアーキテクチャドキュメント生成
随時: /market-team → Go-to-Market戦略調査
```

---

## 上流（仕様駆動）

### 1. Core定義 — /draft-core

**担当**: 人間（AIはヒアリングでサポート）

**役割**: 「プロダクトの本質・誰の課題を・どう解決するか」を整理。技術・実装の話は一切しない。

**成果物**: docs/CORE.md

**動作**:
- docs/CORE.md なし → 新規作成（ヒアリング → 壁打ち → 出力）
- docs/CORE.md あり → 編集モード

**出力フォーマット**:
```markdown
# プロジェクト名

## 誰のためのサービスか
（状況・文脈で描くユーザー像）

## 何に困っているか
（ユーザーの言葉で書く課題）

## どうなったら嬉しいか
- [ ] 理想状態1
- [ ] 理想状態2

## なぜ既存の方法ではダメか
（このサービスの存在意義）

## やらないこと
- xxx

## 一言で言うと
（エレベーターピッチ）
```

### 2. サービス仕様方針 — /draft-spec

**担当**: 人間 + AI

**役割**: CORE.md（Why）と実装（What）の間の「How」を定義する。サービスとしてどう振る舞うか、ユーザーにどんな体験を提供するかを言語化する。技術的な実装方法には触れない。

**成果物**: docs/SPEC.md

**動作**:
- docs/SPEC.md なし → 新規作成（要件確認 → ヒアリング → 壁打ち → 出力）
- docs/SPEC.md あり → 編集モード

**ヒアリング項目**:
1. ユーザー体験の流れ
2. サービスの人格・トーン
3. 判断の基準（導く？選ばせる？後押しする？）
4. やってはいけない体験
5. 成功の手触り

**壁打ち観点**:
- 体験の一貫性
- ユーザーの離脱ポイント
- エッジケースの方針

**出力フォーマット**:
```markdown
# プロジェクト名 — サービス仕様方針

## 体験の全体像
## トーン & マナー
## 判断の方針
## やってはいけない体験
## エッジケースの対応方針
## 成功の手触り
```

### 3. 実装設計 — /draft-arch

**担当**: 人間 + AI

**役割**: SPEC.md（How）を受けて「具体的にどう作るか」を技術的に設計する。技術選定・ディレクトリ構成・データモデル・API設計・コンポーネント分割を言語化する。

**成果物**: docs/ARCHITECTURE.md

**動作**:
- docs/ARCHITECTURE.md なし → 新規作成（要件・仕様確認 → ヒアリング → 壁打ち → 出力）
- docs/ARCHITECTURE.md あり → 編集モード
- 引数にファイルパスを渡す → インポートモード（外部ドキュメントから情報を抽出・整理して生成）

**ヒアリング項目**:
1. 技術的な制約（使いたい/使わざるを得ない技術）
2. ホスティング先（Cloudflare Pages / Heroku / WebARENA SuiteX / Other）
3. データの永続化（ブラウザ / DB / 外部サービス）
4. 認証・権限
5. 外部連携
6. 規模感
7. セキュリティレベル（basic / standard / strict）— ヒアリング結果から推定・確認

**セキュリティレベル**:
- `basic`: 認証なし、外部連携なし
- `standard`: 認証あり、ユーザーデータ保存あり
- `strict`: 決済・機密個人情報を扱う

→ 確定したレベルは CLAUDE.md に `security-level: {レベル}` として書き込む

**出力フォーマット**:
```markdown
# プロジェクト名 — アーキテクチャ設計

## 技術スタック
## ディレクトリ構成
## コンポーネント分割
## データモデル
## API設計
## 認証・権限設計
## やらないこと（技術的スコープ外）
```

### 4. 実装計画 — /plan-assist

**担当**: 人間 + AI

**役割**: コードを書く前に「何を実装するか」を対話で整理。What に集中し、How（実装方法）には踏み込まない。ファイル出力はしない。

**動作**:
1. docs/CORE.md, docs/SPEC.md, docs/ARCH.md を読み込み（存在しないファイルはスキップ）
2. 会話ベースでヒアリング（「今どんな段階？ 何をやろうとしてる？」）
3. ドキュメントの内容とユーザーの状況を照らし合わせて提案・相談
4. スコープを絞り込む
5. 方向が決まったら EnterPlanMode に引き継ぎ

**軌道修正**:

| 逸れた内容 | 戻し方 |
|-----------|--------|
| 技術選定の詳細（ライブラリ比較等） | 「技術選定は実装フェーズで。まず何を実現したいか固めよう」 |
| 実装詳細（コード設計、DB設計） | 「設計はプランモードで。まずゴールを明確にしよう」 |
| スコープの肥大化 | 「全部やりたい気持ちはわかるけど、今回はどこまで？」 |

**ルール**:
- What に集中。How は書かない
- ファイル出力しない（チャット上の対話のみ）
- AskUserQuestion は使わない。普通のチャットで対話
- 提案は必ず CORE/SPEC/ARCH の内容を根拠にする

### 5. 影響範囲調査 — .sc

**担当**: AI

**役割**: 変更前に影響範囲を調査し、並列タスク分割を行う。

---

## 下流（実装・検証）

### エージェントとスキルの使い分け

- **エージェント（`.xx`）**: コマンド一発で走って結果を返すもの。独立したコンテキストで動く
- **スキル（`/xxx`）**: 対話や手順の制御が必要なもの。メインの会話コンテキストを共有したまま動く（中でサブエージェントを使うのはOK）

### エージェント・スキル一覧

**設計**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `/draft-core` | スキル | プロダクトCore整理 | プロジェクト開始時 |
| `/draft-spec` | スキル | サービス仕様方針整理 | Core定義後 |
| `/draft-arch` | スキル | 実装設計（技術・構成・データモデル・API） | 仕様方針後 |
| `/plan-assist` | スキル | 実装計画の対話整理 | 実装前 |
| `/gen-arch` | スキル | アーキテクチャ・画面遷移・規約ドキュメント生成 | 随時 |

**実装**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `.sc` | エージェント | 影響範囲調査・タスク分割 | プラン確定時 |
| `.tpi` | エージェント | 並列実装（自動選択） | 実装時 |

**検証**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `.cc` | エージェント | 静的検証（リント・型チェック・ビルド確認） | 実装後 |
| `.vc` | エージェント | 動的検証（Playwright） | コードチェック後 |
| `.test` | エージェント | テスト実行・結果分析 | 随時 |

**監査**

| 名前 | 種類 | 役割 | メモリ |
|------|------|------|--------|
| `.spc` | エージェント | 仕様適合チェック | project |
| `.cod` | エージェント | コード全体監査 | project |
| `.sec` | エージェント | セキュリティ監査 | user |
| `.arc` | エージェント | アーキテクチャ設計監査 | project |
| `.tck` | エージェント | 統合監査（Agent Teams） | - |

**テスト作成**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `/test-assist` | スキル | 自然言語からPlaywrightテスト自動生成 | テスト作成時 |

**運用**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `.log` | エージェント | 本番ログ分析・障害予兆検出 | デプロイ後・障害調査時 |

**記録（save → load ペア）**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `/save-issue` | スキル | 課題・改善点の即記録 | 随時 |
| `/load-issues` | スキル | ためた issue を調査・具体化・並列実装 | 随時 |
| `/save-plan` | スキル | 計画を `.claude/plans/` に保存 | 計画後 |
| `/load-plans` | スキル | 保存された計画を読み込み・実行 | 別セッション |
| `/save-memo` | スキル | メモの即記録 | 随時 |
| `/load-memos` | スキル | メモを一括エクスポート・アーカイブ | 随時 |

**Git**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `/deploy` | スキル | コミット＆プッシュ（引数なし: Quick / `safe`: フルバリデーション） | 随時 |
| `/backup` | スキル | gitバックアップ（コミットのみ） | 随時 |
| `/rollback` | スキル | バックアップから復元（revert or reset --soft） | 随時 |

**自動化**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `/full-auto-team` | スキル | AIチームが自律的に改善を永続実行（既存プロジェクトの磨き込み向け） | 随時 |
| `/research-team` | スキル | 3視点（UX・コード・競合）で並列調査 | 改善検討時 |
| `/market-team` | スキル | 3視点（訴求・チャネル・競合マーケ）でGo-to-Market戦略調査 | ローンチ準備時 |

**ユーティリティ**

| 名前 | 種類 | 役割 | タイミング |
|------|------|------|-----------|
| `/guide` | スキル | やりたいことを聞いて推奨フローを案内 | いつでも |
| `/ops-check` | スキル | 本番運用の準備状況を診断（DB・ブランチ・監視） | 初回デプロイ前 |
| `/local` | スキル | ローカル開発サーバーを起動してブラウザで開く | 開発時 |

### 検知カバレッジ

| 破壊の種類 | .sc | .cc | .spc | .vc | .cod | .sec | .test | .log |
|-----------|-----|-----|------|-----|------|------|-----|------|
| import/requireの破壊 | ✓ | ✓ | - | - | ✓ | - | - | - |
| CSSセレクタ不一致 | ✓ | ✓ | - | ✓ | - | - | - | - |
| 関数シグネチャ変更 | ✓ | ✓ | - | - | - | - | ✓ | - |
| ルーティング破壊 | ✓ | - | - | ✓ | - | - | ✓ | - |
| レイアウト崩れ | - | - | - | ✓ | - | - | - | - |
| JSランタイムエラー | - | △ | - | ✓ | - | - | ✓ | - |
| APIレスポンスエラー | ✓ | - | - | ✓ | - | - | ✓ | ✓ |
| DBクエリ破壊 | ✓ | - | - | ✓ | - | - | ✓ | - |
| 環境変数欠落 | ✓ | - | - | ✓ | - | ✓ | - | - |
| コンソールエラー | - | - | - | ✓ | - | - | - | - |
| リント違反 | - | ✓ | - | - | ✓ | - | - | - |
| 要件とのズレ | - | - | ✓ | - | - | - | - | - |
| トーン&マナー違反 | - | - | ✓ | - | - | - | - | - |
| 体験フローの逸脱 | - | - | ✓ | - | - | - | ✓ | - |
| スコープ外の実装 | - | - | ✓ | - | - | - | - | - |
| ディレクトリ構成の逸脱 | - | - | ✓ | - | - | - | - | - |
| コンポーネント分割の逸脱 | - | - | ✓ | - | - | - | - | - |
| データモデルの不一致 | - | - | ✓ | - | - | - | - | - |
| API設計の不一致 | - | - | ✓ | - | - | - | - | - |
| 未使用ファイル・デッドコード | - | - | - | - | ✓ | - | - | - |
| 循環参照 | - | - | - | - | ✓ | - | - | - |
| ハードコード秘密情報 | - | - | - | - | - | ✓ | - | - |
| 型エラー | - | ✓ | - | - | - | - | - | - |
| ビルドエラー | - | ✓ | - | - | - | - | - | - |
| Guardテスト失敗 | - | ✓ | - | - | ✓ | - | - | - |
| バージョン整合性（EOL・互換性） | - | - | - | - | ✓ | - | - | - |
| マジックナンバー・ハードコード値 | - | - | - | - | ✓ | - | - | - |
| 重複ロジック（同一処理パターン） | - | - | - | - | ✓ | - | - | - |
| E2Eテスト失敗 | - | - | - | - | - | - | ✓ | - |
| supply chain脆弱性 | - | - | - | - | - | ✓ | - | - |
| git履歴の秘密情報 | - | - | - | - | - | ✓ | - | - |
| 認証・認可の脆弱性 | - | - | - | - | - | ✓ | - | - |
| XSS・インジェクション | - | - | - | - | - | ✓ | - | - |
| APIセキュリティ | - | - | - | - | - | ✓ | - | - |
| 本番クラッシュ・OOM | - | - | - | - | - | - | - | ✓ |
| レスポンスタイム劣化 | - | - | - | - | - | - | - | ✓ |
| プロセス異常（再起動ループ） | - | - | - | - | - | - | - | ✓ |
| 502/503/504エラー | - | - | - | - | - | - | - | ✓ |

---

## 各エージェント詳細

### .sc（pre-safe-checker）

- 変更対象シンボルの洗い出し
- 依存先・依存元トレース
- リスク評価（結合度、テストカバレッジ、クリティカルパス）
- 並列実装グループ分け（順序制約、同時変更禁止ファイル特定）
- 動的参照・間接依存・環境差異・DBマイグレーション影響も考慮

### .tpi（並列実装）

タスクを分析し、依存関係の有無で方式を自動選択する並列実装。メインは調整役のみ。

**自動選択ロジック**:
- 全タスクが独立 → サブエージェント並列（軽量・高速）
- タスク間に依存関係あり or 動的にタスクが増える → Agent Teams

**サブエージェント並列モード**:
- Task tool (Subagents) を使用
- 軽量・トークン効率が良い
- サブエージェント完了まで待機

**Agent Teams モード**:
- 共有タスクリストでメンバー間が協調
- Lead は常時インタラクティブ（待機不要）
- タスク追加・方針変更・直接指示が可能

### .tck（Agent Teams による統合監査）

Agent Teams を使った統合監査。3人の teammate が並列で監査し、指摘の競合を議論・合意形成してから報告する。

**チーム構成**
- **コード品質担当**: .cod 相当（未使用コード、依存関係、構造、リント）
- **仕様適合担当**: .spc 相当（CORE.md / SPEC.md / ARCHITECTURE.md との整合性）
- **セキュリティ担当**: .sec 相当（認証、認可、インジェクション、データ保護）

**特徴**
- 3つの監査を並列実行（時間短縮）
- 指摘が矛盾する場合は teammate 間で議論・合意形成
- Lead が優先度付き統合レポートを作成

**使い方**
1. `.tck` で統合監査チームを起動
2. 3人の teammate が並列で監査実行
3. 矛盾する指摘があれば teammate 間で議論
4. Lead が統合レポートを作成・報告

**有効化**
```bash
export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1
```

### .cc（code-checker）

- 依存関係の存在確認
- ロジック整合性チェック
- 他ファイルへの影響確認
- 拡張子別リント（biome, stylelint, rubocop, ruff等）
- 型チェック（TypeScript: tsc, Python: mypy/pyright）
- ビルド確認（package.jsonにbuildスクリプトがある場合）
- Guardテスト実行（`tests/guard/` が存在する場合）
- Docker環境対応

### .spc（audit-spec-checker）

- 要件との整合性チェック（docs/CORE.md: ユーザー像、課題対応、ゴール導線、スコープ外）
- 仕様方針との整合性チェック（docs/SPEC.md: 体験フロー、トーン&マナー、判断方針、禁止体験、エッジケース）
- アーキテクチャとの整合性チェック（docs/ARCHITECTURE.md: ディレクトリ構成、コンポーネント分割、データモデル、API設計、技術スタック）
- 一貫性チェック（ステップ間のトーンのブレ、AIプロンプトとUIテキストの整合、体験フローとコンポーネント分割の対応）
- コード品質は見ない（バグ・パフォーマンス・セキュリティは .cc / .cod の役割）
- 仕様を正とする（実装が良くても仕様と違えば「ズレ」として報告）
- 重大度: CRITICAL / WARNING / INFO
- **メモリ（project）**: 許容済みの仕様ズレ、仕様解釈の判断、前回からの変化を蓄積

### .vc（visual-checker）

- ローカルサーバー自動検出（CLAUDE.mdのポート設定を優先）
- 3ビューポートでスクリーンショット撮影（Desktop/Tablet/Mobile）
- スクリーンショット保存先: `check_log/screenshots/`
- インタラクションテスト（ボタン・フォーム・モーダル・ドロップダウン）
- コンソールエラー検出（JSエラー・警告・未キャッチ例外）
- APIステータス・タイムアウト検証（4xx/5xx検出、レスポンス形式チェック）
- レポートファイルは出力しない（結果は呼び出し元チャットに返す）

### .cod（audit-code-checker）

- **未使用ファイル検出**: 未参照ファイル・孤立ファイル・重複ファイル
- **デッドコード検出**: 未使用エクスポート・未使用変数/関数・到達不能コード・コメントアウト放置（3行以上）
- **依存関係チェック**: 存在しないファイルへの参照・未インストール/未使用パッケージ・phantom依存・循環参照
- **バージョン整合性チェック**: ランタイムとライブラリの互換性・EOL/非推奨検出・メジャーバージョン乖離・デプロイ先との互換性
- **構造一貫性**: 命名規則の混在・空ディレクトリ・重複コード（コピペ）・重複ロジック（同じ意図の処理パターン）
- **共通化の提案**: 3箇所以上で使われている同一パターンにユーティリティ関数・モジュール切り出し候補を提示
- **品質チェック**: デバッグ残骸・TODO/FIXME/HACK・マジックナンバー/ハードコード値・長大ファイル/関数
- **リントチェック**: biome, stylelint, rubocop, ruff（エラー/警告分離、トップ10集計、自動修正可能件数）
- **Guardテスト実行**: `tests/guard/` が存在する場合のみ
- セキュリティは `.sec` に委譲（本エージェントではスキップ）
- Docker環境対応
- **メモリ（project）**: 前回の監査結果との比較、既知の誤検知、許容済みの技術的負債を蓄積
- **出力**: `check_log/YYYY-MM-DD_HHMM_full_check.md`

### .sec（audit-security-checker）

- 認証・セッション管理（Cookie属性、トークン生成、認証バイパス）
- 認可・アクセス制御（APIエンドポイント認可、水平/垂直権限昇格）
- 入力検証・インジェクション（SQL、XSS、コマンド、パストラバーサル）
- APIセキュリティ（APIキー漏洩、レート制限、CORS、エラー情報開示）
- クライアントサイドセキュリティ（localStorage機密データ、CSP、クリックジャッキング）
- データ保護（機密データ伝送、ログ出力）
- インフラ固有チェック（サーバーレス、コンテナ、DB等、CLAUDE.mdから自動判定）
- 依存関係・設定（supply chain audit、git履歴の秘密情報、SSRF、Race conditions）
- **読み取り専用**: ファイルの変更は一切しない
- **メモリ（user）**: セキュリティパターン、脆弱性箇所、アーキテクチャ上のセキュリティ決定を蓄積
- 重大度: CRITICAL / HIGH / MEDIUM / LOW / INFO

### .arc（audit-architecture-checker）

アーキテクチャ設計の妥当性を監査する。コード品質やセキュリティは見ない（他エージェントの役割）。

- **Phase 1**: 文脈把握（プロダクト性質・ユーザー規模・ライフサイクル段階を推定）
- **Phase 2**: 技術選定の妥当性（言語・FW・DB・インフラ・主要ライブラリ）
- **Phase 3**: アーキテクチャパターン（全体構成・コンポーネント設計・データフロー・アンチパターン検出）
- **Phase 4**: 非機能要件（パフォーマンス・可用性・運用設計・コスト設計）
- **Phase 5**: 組織適合性（オンボーディング容易性・属人化リスク・テスト戦略）
- **Phase 6**: 進化可能性（移行パス・技術的負債の棚卸し）
- **Phase 7**: 総合評価（5段階星評価 × 6観点）
- **読み取り専用**: ファイルの変更は一切しない
- **メモリ（project）**: 前回の監査サマリー、設計リスクの対応状況、許容済みトレードオフを蓄積
- 重大度: CRITICAL / WARNING / INFO
- 各指摘に「⚡ 経験則」として実務経験に基づく警告を付与

### .test（test-runner）

プロジェクトのテストスイートを検出・実行し、結果を分析・報告する。

- テスト環境の自動検出（Jest/Vitest/Playwright/pytest/RSpec）
- Docker環境対応
- テスト実行・結果分析（PASS/FAIL/SKIP）
- FAIL時: ファイルパス・行番号・エラー内容・原因推定・修正案を報告
- 特定テストの指定実行にも対応
- 環境依存の問題（DB接続等）とコードの問題を区別
- flaky test は WARNING として区別
- 重大度: CRITICAL（FAIL） / WARNING（スキップ・環境未整備） / INFO（カバレッジ等）

### .log（log-checker）

本番環境のログを取得・分析し、障害の予兆や劣化を検出する。ファイル保存せず、ターミナルに直接報告。

- **プラットフォーム自動判定**: CLAUDE.md / ARCHITECTURE.md / `git remote -v` からデプロイ先を特定
- **対応プラットフォーム**: Heroku / Cloudflare Pages / Cloudflare Workers / Railway / VPS / FTP
- **Heroku**: `heroku logs -n 500` + `heroku ps` + `heroku releases -n 5` を並列取得
- **Cloudflare Pages**: ビルドログ・デプロイ状態（ランタイムログはDashboard案内）
- **Cloudflare Workers**: `wrangler tail` で短時間取得
- **Railway**: `railway logs --limit 500`
- **VPS**: SSH経由 or ユーザーにログ貼り付け依頼
- **エラーパターン検出**:
  - 🔴 Critical: クラッシュ・OOM・502/503/504・再起動ループ・Herokuエラーコード（H10/H20/H21/H99/R15）
  - ⚠️ Warning: 500レスポンス・タイムアウト・接続拒否・メモリ超過（R14）
  - 💡 Info: レスポンスタイム劣化・デプロイ失敗履歴・非推奨警告
- **プロセス健全性チェック**: dyno状態・再起動頻度・uptime
- **リリース履歴チェック**: 最終デプロイ経過日数・ロールバック有無
- **レスポンスタイム集計**（取得可能な場合）: 平均・最大・5000ms超件数
- **読み取り専用**: ログの取得と分析のみ。修正・設定変更は一切しない
- **メモリ（project）**: 前回のログ診断結果との比較

### /deploy

add → commit → push を実行するスキル。引数でモードを切り替える。

**モード**:
- `/deploy`（Quick）— 即実行。バリデーションなし
- `/deploy safe`（Safe）— 安全バリデーション + ユーザー確認付き

**共通動作**:
1. CLAUDE.mdの「Git運用」セクションからリモート名・ブランチ・デプロイ方式を読み取る
2. 未設定ならARCHITECTURE.mdから推定、なければヒアリングしてCLAUDE.mdに記録
3. リモート未設定ならリポジトリもセットアップ
4. FTPデプロイが必要な場合 → GitHub Actionsワークフロー自動生成、Secrets登録を案内・確認待ち
5. **DBスキーマ変更チェック（モード問わず）**: `*.sql` やマイグレーションファイルの変更を検出したら警告
6. 変更ファイルを個別に `git add`（機密ファイルは除外）
7. コミットメッセージ自動生成・コミット（Co-Authored-By 付き）
8. CLAUDE.mdの設定に従ってプッシュ（--force 禁止）

**Safeモード追加ステップ**:
- 安全バリデーション（保護ブランチ警告、機密ファイル検出、DBスキーマ変更警告、環境変数追加の確認）
- 差分確認をユーザーに表示
- リモート同期チェック（fetch → コンフリクト検出）
- Herokuの場合はデプロイログ確認・エラー時ロールバック提案
- FTPデプロイの場合はGitHub Actions実行状況の確認案内

### /backup

- CLAUDE.md更新チェック（構造・設計変更があれば反映）
- git初期化チェック（.git がなければ git init）
- .gitignore補完（機密ファイル・依存関係・ビルド成果物・OS/エディタファイル・ログ）
- 機密ファイルチェック（ステージングから除外・警告）
- 個別ファイルステージング（`git add -A` は使わない）
- コミットメッセージ自動生成（Co-Authored-By付き）
- プッシュはしない

### /rollback

過去のgitコミット（`/backup` で作成されたもの含む）から復元する。

**動作**:
1. 未コミット変更があれば警告（先に `/backup` するか確認）
2. 直近20件のコミット履歴を表示
3. 復元先をユーザーが選択
4. 復元方法を選択:
   - **安全な復元（推奨）**: `git revert --no-commit` で新コミットとして復元（履歴が残る）
   - **完全な巻き戻し**: `git reset --soft` で指定コミットまで戻す（変更はステージングに残る）
5. 復元結果を報告

**ポイント**:
- `git reset --hard` は使わない（変更が完全に消えるため）
- `/backup` とセットで使う。「セーブ → ロード」の関係

### /test-assist

テストしたい操作を日本語で言うだけでPlaywright E2Eテストコードを自動生成する。

**フロー**:
1. 「どの操作をテストしたいですか？」とヒアリング
2. 開始URL特定（CLAUDE.md or ポートスキャン）
3. Playwright環境のセットアップ確認
4. MCP（Playwright）で操作を再現・記録
5. 記録からテストコード生成（`tests/test-assist/{name}.spec.ts`）
6. テスト実行・検証（FAIL時は最大2回リトライ）
7. 完了報告

**ポイント**:
- ファイルパスの知識は不要。「決済フローが壊れたら困る」と言えばいい
- セレクタは安定性優先（role > text > label > testid > CSS）
- 生成されたテストは `.cc` や `.tck` のタイミングで自動実行される

### /gen-arch

コードベースを分析し、以下の3ドキュメントを `docs/current/` に生成（上書き）:

- **docs/current/architecture.md** — 技術スタック、ディレクトリ構成、アーキテクチャ概要図（ASCII）、データフロー、データモデル、外部連携
- **docs/current/screen-flow.md** — 画面遷移図（ASCII）、ユーザージャーニー、画面一覧、APIエンドポイント一覧、主要な状態遷移、**主要な条件分岐図**
- **docs/current/component-rules.md** — ファイル命名規則、コンポーネント設計パターン、バックエンド構成規約、共通ルール、アンチパターン

**条件分岐図の対象**:
- ミドルウェア/ガードの認証・権限チェック
- ページ初期化時の認証チェック・リダイレクト
- データ処理の信頼度判定・保存ロジック
- モード切替ロジック
- エラーハンドリングのリトライ/フォールバック

**docs/ と docs/current/ の使い分け**:
- `docs/` — 人が決めた設計方針（CORE.md, SPEC.md, ARCHITECTURE.md）
- `docs/current/` — 今のコードの実態（/gen-arch で逆引き生成）

探索対象: フロントエンド（HTML/JSX/Vue等）、バックエンド（JS/TS/Ruby/Python等）、スキーマ、ルーティング、インフラ構成ファイル、状態管理（state, status, phase, mode, step等）、条件分岐（if/else, switch）

注意: 既存ファイルはWrite前に必ずReadする（Writeツールは未読ファイルへの上書きをブロックするため）

### /save-issue

開発中に気づいた小さな課題を即記録する。最速で終了。

**動作**:
1. 「記録する内容を入力してください:」と表示して停止
2. 入力内容からキーワードを抽出してファイル名を生成
3. `.claude/issues/{YYYY-MM-DD}_{HHmm}_{keyword}.md` に記録
4. 「記録しました」と1行だけ表示して終了

**出力フォーマット**:
```markdown
# {入力内容そのまま}
- **登録日:** {YYYY-MM-DD HH:mm}
- **ステータス:** 未対応
```

**ポイント**:
- 優先度・カテゴリなどの追加情報は聞かない
- 記録後にフォローしない。会話を止めない

### /load-issues

`.claude/issues/` にためた issue をまとめて調査・具体化し、並列実装する。issue は曖昧な一言メモなので、plan とは違い「調査 → 具体化」フェーズが必須。

**処理フロー**:
1. 未対応の issue を一覧表示（`done/` サブディレクトリは対象外）
2. 実行対象を選択（全て / 選択 / 確認のみ）
3. 各 issue を並列調査（関連ファイル特定・修正方針の具体化）
4. 不明点があればユーザーに確認
5. 調査結果と競合マップを表示
6. `.tpi` パターンで並列実装（競合する issue 間は blockedBy 設定）
7. 完了した issue のステータスを更新し、`.claude/issues/done/` に移動

**/save-plan → /load-plans との違い**:
- `/save-plan` は具体的な実装ステップが確定済み → そのまま実行
- `/save-issue` は曖昧な一言メモ → `/load-issues` で調査・具体化してから実装

### /save-memo

開発中に気になったことや確認したい内容をフリーワードで即記録する。

**動作**:
1. 「メモの内容を入力してください:」と表示して停止
2. 入力内容からキーワードを抽出してファイル名を生成
3. `.claude/memos/{YYYY-MM-DD}_{HHmm}_{keyword}.md` に記録
4. 「記録しました」と1行だけ表示して終了

**ポイント**:
- カテゴリ・優先度などの追加情報は聞かない
- `/save-issue` と同じ「即記録」パターン

### /load-memos

`.claude/memos/` にためたメモをまとめた `.md` ファイルを生成し、元ファイルをアーカイブする。

**処理フロー**:
1. 未処理のメモを収集
2. プロジェクトルートに `{YYYY-MM-DD}_memos.md` を生成（チェックリスト形式）
3. 対象ファイルのステータスを「エクスポート済」に更新
4. `.claude/memos/done/` に移動

### /research-team

3つの視点からサブエージェントで並列調査し、結果を統合して報告する。実装はしない。

**調査員（サブエージェント — 使い捨て）**:

| 調査員 | 視点 |
|--------|------|
| **A** | ユーザー体験（ブラウザ操作で実際に触って確認） |
| **B** | プロダクト品質（CORE.md逆算、コードと仕様のギャップ・アクセシビリティ） |
| **C** | 競合・トレンド（Web検索） |

**ルール**:
1. **調査だけ。** 実装・コード変更はしない
2. **統合せよ。** 3視点の結果を突き合わせ、重複排除・優先度付けして報告
3. **聞くのは1回。** テーマ確認だけ。指定なしならプロダクト全体

**フロー**:
1. ユーザーに調査テーマを確認（指定なしならプロダクト全体）
2. docs/CORE.md, docs/SPEC.md があれば読む
3. A/B/C を並列起動
4. 結果を統合して優先度付き報告

**/full-auto-team との違い**:
- `/research-team` — 調査・報告のみ。実装しない。単発で使える
- `/full-auto-team` — 調査→実装→検証→改善を永続ループ

### /market-team

3つのマーケティング視点からサブエージェントで並列調査し、Go-to-Market戦略の材料を報告する。実装はしない。

**調査員（サブエージェント — 使い捨て）**:

| 調査員 | 視点 |
|--------|------|
| **A** | ポジショニング・メッセージング（CORE.md逆算、訴求軸導出） |
| **B** | チャネル・成長戦略（WebSearchで配信経路調査） |
| **C** | 競合マーケティング分析（競合の訴求・LP・集客手法） |

**ルール**:
1. **調査だけ。** 実装・コード変更はしない
2. **届く実感で優先度をつけろ。** 判定基準: その施策を実行したらユーザーに届く量・質が変わるか？
3. **統合は「批判的思考」。** 3視点をきれいに並べるだけでは不十分。矛盾を洗い出し、楽観バイアスを疑い、「本当はどうすべきか」まで踏み込む
4. **聞くのは1回。** プロダクト概要とターゲットの確認のみ

**フロー**:
1. ユーザーにプロダクト概要・ターゲット・調査テーマを確認（CORE.md/SPEC.mdがあればそこから推定）
2. docs/CORE.md, docs/SPEC.md があれば読む
3. A/B/C を並列起動
4. 結果を統合して報告（実行インパクト順）
5. **矛盾分析（Devil's Advocate）** — 調査員間の矛盾・楽観バイアス・訴求と実態の乖離・ターゲットとチャネルの整合性・未検証の前提を洗い出し、「本当にやるべきこと」を優先度付きで提示
6. 統合レポートを `docs/current/` に保存

**/research-team との違い**:
- `/research-team` — プロダクト改善のための調査（UX・コード・競合）
- `/market-team` — プロダクトを市場に届けるための調査（訴求・チャネル・競合マーケ）

### /guide

プロジェクトの状態（CORE.md/SPEC.md/ARCHITECTURE.md/コードの有無）を自動判定し、やりたいことに応じた推奨フローを案内する。実行はしない。

### /ops-check

本番運用の準備状況を診断するスキル。初回デプロイ前に1回実行すればよい。

**チェック項目**:
1. **DBバックアップ**: 自動バックアップ設定の有無を確認。未設定ならDB/ホスティングに応じた設定方法を案内。復元テストの実施も確認
2. **ブランチ戦略**: mainブランチに直接デプロイしていないか確認。開発用ブランチの分離を提案
3. **監視・アラート**: 死活監視（UptimeRobot等）とエラー通知（Sentry等）の設定を確認。未設定なら案内

**動作**:
- CLAUDE.mdに `ops-check: done` がなければチェック実行
- 全項目確認後、CLAUDE.mdにフラグを記録（次回 `/guide` で「済み」と判定）
- 「後でやる」→ フラグなし（次回また案内される）
- 「不要」→ スキップとして記録

### /local

プロジェクトのCLAUDE.mdから開発コマンドを読み取り、ローカルサーバーを起動してブラウザで開く。

**動作**:
1. CLAUDE.mdから起動コマンドとポートを特定（記載がなければ package.json / Gemfile / manage.py から自動検出）
2. ポート競合チェック（使用中なら全プロセス情報を提示 → 終了/別ポート/キャンセルを選択）
3. バックグラウンドでサーバー起動
4. 起動確認（2秒待ってポートのLISTEN状態を確認。失敗時はログ表示して終了）
5. ブラウザで `http://localhost:{port}` を開く

### /save-plan

現在の会話で立てた計画を `.claude/plans/` に保存する。

**保存内容**:
- 概要
- 変更対象ファイル
- 参照ファイル
- 実行ステップ
- 注意事項

**ファイル名**: 自動生成（`{YYYY-MM-DD}_{HHmm}_{概要キーワード}.md`）

**用途**: 計画を立てたが今は実行しない時。別セッションで `/load-plans` から実行できる。

### /load-plans

`.claude/plans/` に保存された計画を読み込み、競合分析を行い、実行する。

**処理フロー**:
1. 未実行の計画を一覧表示（`done/` サブディレクトリは対象外）
2. 変更対象ファイルの競合を分析
3. 実行方式を提案（競合なし→全並列、競合あり→直列/部分並列）
4. `.tpi` で実行
5. 完了した計画のステータスを更新し、`.claude/plans/done/` に移動

**競合分析**:
- 同じファイルを変更する計画は競合
- 競合する計画間には依存関係を設定して直列実行

---

## モデル配分

スキルの処理負荷に応じてモデルを使い分ける。

| モデル | スキル |
|-------|-------|
| **opus** | draft-core, draft-spec, draft-arch, plan-assist, test-assist, research-team, market-team, full-auto-team, load-issues, load-plans |
| **sonnet** | gen-arch, deploy, log-checker |
| **haiku** | local, backup, rollback, save-issue, save-plan, save-memo, load-memos, guide |

**基準**: 壁打ち・設計判断・複雑な調査 → opus。構造的な生成・手順実行 → sonnet。単純な記録・ルックアップ → haiku。

---

## 設定ファイル

### ~/.claude/settings.json（Claude Code 設定）

```json
{
  "language": "日本語",
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  },
  "permissions": {
    "deny": [
      "Bash(rm -rf *)",
      "Bash(rm *)",
      "Bash(sudo *)",
      "Bash(dd *)",
      "Bash(chmod 000 *)",
      "Bash(format *)",
      "Bash(del /f *)",
      "Bash(rmdir /s *)",
      "Read(.env*)",
      "Read(**/secrets/**)",
      "Read(**/*credential*)",
      "Edit(.env*)",
      "Edit(**/secrets/**)",
      "Edit(**/*credential*)"
    ],
    "ask": [
      "Bash(git push *)",
      "Bash(git reset --hard *)",
      "Bash(git checkout .)",
      "Bash(docker *)",
      "Bash(docker-compose *)"
    ]
  }
}
```

**運用方針**:
- `claude --dangerously-skip-permissions` をデフォルトで使用（エイリアス推奨）
- 代わりに deny リストで危険な操作をブロック
- 機密ファイル（.env、secrets、credential）は読み取り・編集を禁止
- git push、docker 系は確認を挟む

```bash
# ~/.bashrc or ~/.zshrc
alias claude-a='claude --dangerously-skip-permissions'
```

### ~/.claude/CLAUDE.md（Claude Code 共通設定）

ユーザールートに配置。全プロジェクト共通で Claude Code が従うルール。

```markdown
# ショートカットコマンド

* .sc → pre-safe-checker サブエージェントを呼び出す
* .tpi → 並列実装。タスクを分析し、依存関係の有無で方式を自動選択する。メインは調整役のみ（実装はせず、タスク振り分け・結果統合・報告を担当）。
  - 全タスクが独立 → サブエージェント並列（軽量・高速）
  - タスク間に依存関係あり or 動的にタスクが増える → Agent Teams（共有タスクリスト、メンバー間通信、Lead常時インタラクティブ）
* .test → test-runner サブエージェントを呼び出す（テスト実行・結果分析）
* .cc → code-checker サブエージェントを呼び出す（引数なし→直前の実装を検証、引数あり→指定箇所を検証）
* .vc → visual-checker サブエージェントを呼び出す（引数なし→直前の実装を検証、引数あり→指定箇所を検証）
* .spc → audit-spec-checker サブエージェントを呼び出す（仕様適合チェック）
* .cod → audit-code-checker サブエージェントを呼び出す（全体コード監査）
* .sec → audit-security-checker サブエージェントを呼び出す（セキュリティ監査）
* .arc → audit-architecture-checker サブエージェントを呼び出す（アーキテクチャ設計監査）
* .log → log-checker サブエージェントを呼び出す（本番ログ分析・障害予兆検出）
* .tck → Agent Teams で統合監査を実行する。3人のチームメイトを起動し、コード品質（.cod相当）・仕様適合（.spc相当）・セキュリティ（.sec相当）を並列で監査する。チームメイト同士が指摘の競合を議論する。指摘が矛盾する場合はチーム内で合意形成してから報告する。

# 実装タスクのフロー

1. Coreの確認: docs/CORE.md を参照（プロダクトの本質・体験方針・トーン）
2. 仕様の確認: docs/SPEC.md を参照（画面仕様・振る舞い）
3. 依存関係確認: 変更対象ファイルの依存関係を検索し、影響を受けるファイル一覧を把握
4. 設計検討
5. 実装
6. 完了報告

# 依存関係の確認

- class名、id、関数名を変更する前に依存先を検索する
- HTML変更 → 参照しているJS、CSSセレクタを確認
- JS変更 → 呼び出し元、戻り値の期待を確認
- CSS変更 → 同名class/idの使用箇所を確認

# プロジェクトCLAUDE.mdの更新

- 構造・設計に関わる変更をしたら、プロジェクトのCLAUDE.mdに反映する

# エラーの学習

- 技術的なエラーを修正したら rules/learned.md に記録する
- フォーマット: 内容（1行） / 対策（1行）
- 同じ内容が既にあれば追記しない
```

### プロジェクト/CLAUDE.md（プロジェクト仕様）

`/init` で自動生成。プロジェクト固有の構造・設計を記録。

**目的**: Claude Code がファイル探索せずにプロジェクト構造を把握 → コンテキスト削減

```markdown
# プロジェクト名

## 構造
（ディレクトリ構成、主要ファイルの役割）

## 技術スタック
（使用言語、フレームワーク、DB等）

## 設計メモ
（責務分離、データフロー等）
```

**ルール**: 構造・設計に関わる変更をしたら更新する

---

## 仕様ドキュメントの関係

```
docs/CORE.md（Why）
  「プロダクトの本質・誰の課題を・どう解決するか」
      ↓
docs/SPEC.md（How）
  「サービスとしてどう振る舞うか」
  体験フロー / トーン&マナー / 判断方針
      ↓
docs/ARCHITECTURE.md（What）
  「プログラムとしてどう作るか」
  技術スタック / ディレクトリ構成 / データモデル / API設計
      ↓
CLAUDE.md + 実装コード
  「実際のコード」

────────────────────────────
docs/current/（今のコードの実態）
├── architecture.md
├── screen-flow.md
└── component-rules.md
→ /gen-arch で逆引き生成
```

| ドキュメント | 作成スキル | 現状出力スキル |
|-------------|-----------|---------------|
| docs/CORE.md（Why） | `/draft-core` | — |
| docs/SPEC.md（How） | `/draft-spec` | — |
| docs/ARCHITECTURE.md（What） | `/draft-arch` | — |
| docs/current/*（実態） | — | `/gen-arch` |

- **docs/CORE.md** → `/draft-core` で作成（インポートモードで外部ドキュメントからも変換可能）
- **docs/SPEC.md** → `/draft-spec` で作成（インポートモードで外部ドキュメントからも変換可能）
- **docs/ARCHITECTURE.md** → `/draft-arch` で作成（インポートモードで外部ドキュメントからも変換可能）
- **docs/current/** → `/gen-arch` でコードベースから逆引き生成
- **整合性検証** → `.spc` で実装と仕様のズレを検出

---

## 監査エージェントの使い分け

| 監査タイプ | エージェント | 対象 | タイミング |
|-----------|-------------|------|-----------|
| 仕様適合 | `.spc` | docs/CORE.md / docs/SPEC.md / docs/ARCHITECTURE.md と実装の整合性 | 機能実装後 |
| コード品質 | `.cod` | 未使用コード、依存関係、バージョン整合性、構造、重複ロジック、品質、リント | リリース前、リファクタ後 |
| セキュリティ | `.sec` | 認証、認可、インジェクション、データ保護 | リリース前、セキュリティレビュー時 |
| アーキテクチャ設計 | `.arc` | 技術選定、設計パターン、非機能要件、進化可能性 | 設計レビュー時、リリース前 |

4つの監査は独立しており、目的に応じて使い分ける。

**全部実行する場合**: `.spc` → `.cod` → `.sec` → `.arc` の順を推奨（仕様ズレ → コード品質 → セキュリティ → 設計妥当性の順で修正する方が効率的）

**Agent Teams で一括実行**: `.tck` で3つを並列実行、指摘の競合を議論・合意形成してから報告

---

## リリースフロー

新規プロジェクトの立ち上げフローは「クイックスタート」セクションに記載。ここではリリース時と、リリース後の運用フローを定義する。

### 初回リリース

```
1. /ops-check → 本番運用の準備状況を診断（DB・ブランチ・監視）
2. .spc → 仕様適合チェック
3. .cod → コード全体監査（バージョン整合性含む）
4. .sec → セキュリティ監査
5. .arc → アーキテクチャ設計監査
6. /deploy safe → 安全デプロイ
7. .log → デプロイ後のログ確認（正常起動・エラーなし確認）
```

### 通常リリース

```
1. .spc → 仕様適合チェック
2. .cod → コード全体監査
3. .sec → セキュリティ監査
4. /deploy safe → 安全デプロイ
5. .log → デプロイ後のログ確認
```

### 定期メンテナンス

```
随時: .log → 予兆検知（エラー率上昇・レスポンスタイム劣化）
随時: .cod → バージョン整合性チェック（EOL・互換性の定期確認）
```

---

## 障害対応フロー

### 障害検知

- `/ops-check` で設定した監視（UptimeRobot等）からアラート通知
- ユーザー報告
- `.log` の定期実行で予兆検知

### 対応フロー

```
1. .log → ログ取得・原因特定（🔴 Critical の内容を確認）
2. 判断: 修正可能か？ → Yes: 修正へ / No: /rollback で巻き戻し
3. 修正した場合:
   a. .cc → 修正箇所の静的検証
   b. .vc → 修正箇所の動的検証
   c. /deploy → デプロイ
   d. .log → 復旧確認
4. rules/learned.md に記録（何が起きて何をしたか）
```

### 責務

| フェーズ | 担当 | ツール |
|---------|------|--------|
| 検知 | 自動（監視ツール） | UptimeRobot / Sentry |
| 原因特定 | AI | `.log` |
| 修正 or ロールバック判断 | 人間 | — |
| 修正実装 | AI | `.tpi` / 手動 |
| 検証 | AI | `.cc` → `.vc` |
| デプロイ | 人間（承認） | `/deploy` |
| 記録 | AI | `rules/learned.md` |

### 予防

| 予防手段 | ツール | 内容 |
|---------|--------|------|
| バージョン互換性 | `.cod` | アップグレード前に整合性チェック |
| 予兆検知 | `.log` | エラー率上昇・タイムアウト増加の検出 |
| 監視設定 | `/ops-check` | 死活監視・エラー通知の初期設定 |
| 学習 | `rules/learned.md` | 過去の障害パターンの蓄積 |

---

## 自律開発モード — /full-auto-team

> **注意**: このモードは上記の手動フローとは根本的に異なる。他のエージェント・スキルが「人間がコマンドで呼ぶ」前提なのに対し、/full-auto-team は「止めるまで回り続ける」自律モード。既存のエージェント・スキルを内部で組み合わせて使う上位レイヤーという位置づけ。

> **前提**: モックアップが動いている状態から使う。新規開発のゼロからの構築には向かない（手動フローで先にベースを作る）。

ユーザーはPO。AI開発チームが自律的にUI/UX・アクセシビリティ・機能拡充を改善し続ける。「ストップ」「終了」「一旦止めて」と言われるまで止まらない。

**Leadのルール**:
1. **コードを書くな。** 全てメンバーに任せる
2. **止まるな。** サイクル完了後、次の改善を提案し続ける
3. **聞きすぎるな。** 技術判断はチームが行う

**チーム構成（全員Teams常駐）**:

| メンバー | 役割 |
|---------|------|
| **Lead（自分）** | 調査結果の統合・判断・結果報告 |
| **A** | 調査（ユーザー体験 — Playwright） |
| **B** | 調査（CORE.md逆算 — コード・docs・a11y） |
| **C** | 調査（競合 — WebSearch） |
| **D** | 設計 + 実装管理（サブエージェントを起動して実装させる） |

実装とコードチェックだけサブエージェント（使い捨て）:
- **実装者**: Dが Task(general-purpose) で起動。並列可
- **検証**: Task(code-checker) で毎回使い捨て起動

**起動フロー**:
1. ユーザーに**変更してほしくない箇所**だけ聞く（それ以外は全てチームが判断）
2. docs/（CORE.md / SPEC.md）があれば読む
3. TeamCreate → A/B/C/D を起動 → サイクル開始

**サイクル**:
```
A/B/Cが調査 → Leadが統合・判断 → Dが設計・タスク分割 → サブエージェントで実装 → 検証(.cc) → ユーザーへ結果報告 → 次の調査 → 繰り返し
```

- 検証でCRITICALが出たらDに修正依頼
- 各サイクル完了時、Leadがユーザーに実施内容・変更ファイル・次の改善予定を簡潔に報告（承認は不要、報告のみ）
- 「ストップ」で shutdown_request → TeamDelete
